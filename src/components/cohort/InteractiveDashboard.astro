---
import { parseConsortiumCSV, groupCharacteristics } from '../../utils/csvParser';
import { readFile } from 'fs/promises';
import { join } from 'path';

// Read and parse the detailed CSV file for Charts view
const csvPath = join(process.cwd(), 'src', 'data', 'consortium_t1_by_year_site_1113.csv');
const csvContent = await readFile(csvPath, 'utf-8');
const data = parseConsortiumCSV(csvContent);
const groupedChars = groupCharacteristics(data);

// Read the overall CSV file for Table view and Export
const overallCsvPath = join(process.cwd(), 'src', 'data', 'overall_1113.csv');
const overallCsvContent = await readFile(overallCsvPath, 'utf-8');

// Helper to parse CSV line with quoted values
function parseCSVLineHelper(line: string, preserveFirstColumnSpaces: boolean = false): string[] {
  const result: string[] = [];
  let current = '';
  let inQuotes = false;

  for (let i = 0; i < line.length; i++) {
    const char = line[i];

    if (char === '"') {
      inQuotes = !inQuotes;
    } else if (char === ',' && !inQuotes) {
      // For first column (index 0), preserve leading spaces if requested
      if (preserveFirstColumnSpaces && result.length === 0) {
        result.push(current.replace(/^"|"$/g, '')); // Remove quotes but keep spaces
      } else {
        result.push(current.trim());
      }
      current = '';
    } else {
      current += char;
    }
  }

  // Handle last field
  if (preserveFirstColumnSpaces && result.length === 0) {
    result.push(current.replace(/^"|"$/g, ''));
  } else {
    result.push(current.trim());
  }
  return result;
}

// Parse overall CSV into simple format
function parseOverallCSV(content: string) {
  const lines = content.trim().split('\n');
  const headers = parseCSVLineHelper(lines[0]);

  const tableData: Array<{ characteristic: string; values: Record<string, string> }> = [];

  for (let i = 1; i < lines.length; i++) { // Start from row 1 to include Years row
    const values = parseCSVLineHelper(lines[i]);
    const characteristic = values[0];

    if (!characteristic) continue;

    const row: Record<string, string> = {};
    for (let j = 1; j < headers.length && j < values.length; j++) {
      row[headers[j]] = values[j] || '-';
    }

    tableData.push({ characteristic, values: row });
  }

  return { headers: headers.slice(1), data: tableData }; // Skip "Characteristics" column header
}

const overallData = parseOverallCSV(overallCsvContent);

// Convert to JSON for client-side use
const dataJson = JSON.stringify({
  allSites: data.allSites,
  allYears: data.allYears,
  characteristics: data.characteristics.map(c => ({
    variable: c.variable,
    sites: Object.fromEntries(
      Array.from(c.sites.entries()).map(([site, yearMap]) => [
        site,
        Object.fromEntries(yearMap)
      ])
    )
  })),
  siteYearData: data.siteYearData.map(d => ({
    site: d.site,
    year: d.year,
    characteristics: Object.fromEntries(d.characteristics)
  }))
});

const overallDataJson = JSON.stringify(overallData);

const categories = Array.from(groupedChars.keys());
---

<div class="interactive-dashboard bg-white rounded-2xl shadow-xl p-6 md:p-8">
  <!-- Dashboard Header -->
  <div class="mb-8">
    <h2 class="text-3xl font-bold text-gray-800 mb-2">Interactive Data Explorer</h2>
    <p class="text-gray-600 mb-3">
      Explore consortium data across {data.allSites.length} institutions and {data.allYears.length} years.
      Use the filters below to customize your view.
    </p>
    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
      <p class="text-sm text-blue-800">
        <strong>Privacy Notice:</strong> To protect patient privacy, characteristics with values where n &lt; 10 are automatically excluded from display and export.
      </p>
    </div>
  </div>

  <!-- View Toggle -->
  <div class="flex items-center justify-between mb-6 pb-6 border-b-2 border-gray-200">
    <div class="flex gap-2">
      <button
        id="view-charts"
        class="px-6 py-2 bg-clif-burgundy text-white rounded-lg font-semibold hover:bg-clif-burgundy-dark transition-colors"
      >
        Charts
      </button>
      <button
        id="view-table"
        class="px-6 py-2 bg-gray-200 text-gray-700 rounded-lg font-semibold hover:bg-gray-300 transition-colors"
      >
        Table
      </button>
    </div>
  </div>

  <!-- Charts View -->
  <div id="charts-view" class="space-y-6">
    <!-- Filter Controls (Charts only) -->
    <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
      <!-- Site Filter -->
      <div>
        <label class="block text-sm font-semibold text-gray-700 mb-2">
          Select Sites
        </label>
        <div class="relative">
          <button
            id="site-filter-toggle"
            class="w-full bg-white border-2 border-gray-300 rounded-lg px-4 py-2 text-left flex items-center justify-between hover:border-clif-burgundy transition-colors"
          >
            <span id="site-filter-text" class="text-gray-700">All Sites</span>
            <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
            </svg>
          </button>
          <div
            id="site-filter-dropdown"
            class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
          >
            <div class="p-2">
              <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                <input
                  type="checkbox"
                  id="site-all"
                  class="site-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                  checked
                />
                <span class="ml-2 text-sm text-gray-700 font-semibold">All Sites</span>
              </label>
              {data.allSites.map(site => (
                <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                  <input
                    type="checkbox"
                    class="site-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                    value={site}
                    checked
                  />
                  <span class="ml-2 text-sm text-gray-700">{site}</span>
                </label>
              ))}
            </div>
          </div>
        </div>
      </div>

      <!-- Year Filter -->
      <div>
        <label class="block text-sm font-semibold text-gray-700 mb-2">
          Select Years
        </label>
        <div class="relative">
          <button
            id="year-filter-toggle"
            class="w-full bg-white border-2 border-gray-300 rounded-lg px-4 py-2 text-left flex items-center justify-between hover:border-clif-burgundy transition-colors"
          >
            <span id="year-filter-text" class="text-gray-700">All Years</span>
            <svg class="w-5 h-5 text-gray-400" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
            </svg>
          </button>
          <div
            id="year-filter-dropdown"
            class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
          >
            <div class="p-2">
              <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                <input
                  type="checkbox"
                  id="year-all"
                  class="year-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                  checked
                />
                <span class="ml-2 text-sm text-gray-700 font-semibold">All Years</span>
              </label>
              {data.allYears.map(year => (
                <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                  <input
                    type="checkbox"
                    class="year-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                    value={year}
                    checked
                  />
                  <span class="ml-2 text-sm text-gray-700">{year}</span>
                </label>
              ))}
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Data coverage note - always visible -->
    <div class="bg-blue-50 border-l-4 border-blue-400 p-3 rounded">
      <p class="text-sm text-blue-800">
        <strong>Data Coverage:</strong> Sites have varying data coverage periods (e.g., some sites have data from 2011-2025, others from 2018-2024).
        Use the <strong>Table</strong> view to see years covered for each site, then select appropriate sites and years for valid comparisons.
      </p>
    </div>

    <!-- Chart Builder with Sidebar -->
    <div class="flex gap-6">
      <!-- Left Sidebar - Characteristic Categories -->
      <div class="w-80 flex-shrink-0">
      <div class="bg-white border-2 border-gray-200 rounded-lg overflow-hidden sticky top-4">
        <!-- Search Box -->
        <div class="p-4 border-b border-gray-200">
          <input
            type="text"
            id="characteristic-search"
            placeholder="Search for a filter"
            class="w-full px-3 py-2 border border-gray-300 rounded-lg text-sm focus:border-clif-burgundy focus:ring-2 focus:ring-clif-burgundy focus:ring-opacity-50"
          />
        </div>

        <!-- Categories List -->
        <div id="categories-list" class="max-h-[600px] overflow-y-auto">
          <!-- Categories will be populated by JavaScript -->
        </div>
      </div>
    </div>

    <!-- Right Content Area -->
    <div class="flex-1 space-y-6">
      <!-- Chart Builder Controls -->
      <div class="bg-gray-50 rounded-lg p-6">
        <h3 class="text-lg font-bold text-gray-800 mb-4">Chart Builder</h3>

        <div class="grid grid-cols-1 md:grid-cols-3 gap-4">
          <!-- Chart Type Selector -->
          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">Chart Type</label>
            <select
              id="chart-type-select"
              class="w-full bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 focus:border-clif-burgundy focus:ring-2 focus:ring-clif-burgundy focus:ring-opacity-50"
            >
              <!-- Options populated dynamically by JavaScript based on selected characteristic and grouping -->
            </select>
          </div>

          <!-- X-Axis Selector -->
          <div>
            <label class="block text-sm font-semibold text-gray-700 mb-2">Group By</label>
            <select
              id="chart-xaxis-select"
              class="w-full bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 focus:border-clif-burgundy focus:ring-2 focus:ring-clif-burgundy focus:ring-opacity-50"
            >
              <option value="site">Site</option>
              <option value="year">Year</option>
            </select>
          </div>

          <!-- Generate Button -->
          <div class="flex items-end">
            <button
              id="generate-chart-btn"
              class="w-full px-4 py-2 bg-clif-burgundy text-white rounded-lg font-semibold hover:bg-clif-burgundy-dark transition-colors disabled:bg-gray-400 disabled:cursor-not-allowed"
              disabled
            >
              Generate Chart
            </button>
          </div>
        </div>

        <!-- Respiratory Support Denominator Selector (hidden by default) -->
        <div id="resp-denominator-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Calculate as % of:</label>
            <div class="flex items-center gap-4">
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="resp-denominator" value="imv" checked class="text-clif-burgundy focus:ring-clif-burgundy">
                <span class="text-sm text-gray-700">Total IMV Hospitalizations</span>
              </label>
              <label class="flex items-center gap-2 cursor-pointer">
                <input type="radio" name="resp-denominator" value="hospitalizations" class="text-clif-burgundy focus:ring-clif-burgundy">
                <span class="text-sm text-gray-700">Total Hospitalizations</span>
              </label>
            </div>
          </div>
        </div>

        <!-- Location Type Selector (for First location at IMV start) -->
        <div id="location-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Location Types:</label>
            <div class="relative">
              <button
                id="location-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="location-type-text">All Locations</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="location-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input
                      type="checkbox"
                      id="location-all"
                      class="location-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                      checked
                    />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Locations</span>
                  </label>
                  <div id="location-options-container">
                    <!-- Options populated dynamically -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Ventilator Mode Type Selector (for Initial ventilator mode) -->
        <div id="vent-mode-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Mode Types:</label>
            <div class="relative">
              <button
                id="vent-mode-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="vent-mode-type-text">All Modes</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="vent-mode-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input
                      type="checkbox"
                      id="vent-mode-all"
                      class="vent-mode-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                      checked
                    />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Modes</span>
                  </label>
                  <div id="vent-mode-options-container">
                    <!-- Options populated dynamically -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Ethnicity Type Selector (for Ethnicity consolidated) -->
        <div id="ethnicity-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Ethnicity Types:</label>
            <div class="relative">
              <button
                id="ethnicity-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="ethnicity-type-text">All Types</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="ethnicity-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input
                      type="checkbox"
                      id="ethnicity-all"
                      class="ethnicity-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                      checked
                    />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Types</span>
                  </label>
                  <div id="ethnicity-options-container">
                    <!-- Options populated dynamically -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Race Type Selector (for Race consolidated) -->
        <div id="race-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Race Types:</label>
            <div class="relative">
              <button
                id="race-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[250px] hover:border-clif-burgundy transition-colors"
              >
                <span id="race-type-text">All Types</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="race-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input
                      type="checkbox"
                      id="race-all"
                      class="race-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                      checked
                    />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Types</span>
                  </label>
                  <div id="race-options-container">
                    <!-- Options populated dynamically -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Sex Type Selector (for Sex consolidated) -->
        <div id="sex-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Sex Types:</label>
            <div class="relative">
              <button
                id="sex-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="sex-type-text">All Types</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="sex-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input
                      type="checkbox"
                      id="sex-all"
                      class="sex-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
                      checked
                    />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Types</span>
                  </label>
                  <div id="sex-options-container">
                    <!-- Options populated dynamically -->
                  </div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Admission Type Selector -->
        <div id="admission-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Admission Types:</label>
            <div class="relative">
              <button
                id="admission-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="admission-type-text">All Types</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="admission-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input type="checkbox" id="admission-type-all" class="admission-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" checked />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Types</span>
                  </label>
                  <div id="admission-type-options-container"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- First Admission Location Selector -->
        <div id="first-admission-location-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Location Types:</label>
            <div class="relative">
              <button
                id="first-admission-location-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[200px] hover:border-clif-burgundy transition-colors"
              >
                <span id="first-admission-location-text">All Locations</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="first-admission-location-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input type="checkbox" id="first-admission-location-all" class="first-admission-location-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" checked />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Locations</span>
                  </label>
                  <div id="first-admission-location-options-container"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Encounter Type Selector -->
        <div id="encounter-type-selector" class="mt-4 hidden">
          <div class="flex items-center gap-4">
            <label class="text-sm font-semibold text-gray-700">Encounter Types:</label>
            <div class="relative">
              <button
                id="encounter-type-toggle"
                class="bg-white border-2 border-gray-300 rounded-lg px-3 py-2 text-sm text-gray-700 flex items-center justify-between min-w-[250px] hover:border-clif-burgundy transition-colors"
              >
                <span id="encounter-type-text">All Types</span>
                <svg class="w-4 h-4 text-gray-400 ml-2" fill="currentColor" viewBox="0 0 20 20">
                  <path fill-rule="evenodd" d="M5.293 7.293a1 1 0 011.414 0L10 10.586l3.293-3.293a1 1 0 111.414 1.414l-4 4a1 1 0 01-1.414 0l-4-4a1 1 0 010-1.414z" clip-rule="evenodd"/>
                </svg>
              </button>
              <div
                id="encounter-type-dropdown"
                class="hidden absolute z-50 mt-2 w-full bg-white border-2 border-gray-200 rounded-lg shadow-lg max-h-64 overflow-y-auto"
              >
                <div class="p-2">
                  <label class="flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer">
                    <input type="checkbox" id="encounter-type-all" class="encounter-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" checked />
                    <span class="ml-2 text-sm text-gray-700 font-semibold">All Types</span>
                  </label>
                  <div id="encounter-type-options-container"></div>
                </div>
              </div>
            </div>
          </div>
        </div>

        <!-- Selected Characteristic Display -->
        <div id="selected-characteristic-display" class="mt-4 hidden">
          <div class="flex items-center gap-2 text-sm text-gray-600">
            <svg class="w-4 h-4" fill="currentColor" viewBox="0 0 20 20">
              <path fill-rule="evenodd" d="M10 18a8 8 0 100-16 8 8 0 000 16zm3.707-9.293a1 1 0 00-1.414-1.414L9 10.586 7.707 9.293a1 1 0 00-1.414 1.414l2 2a1 1 0 001.414 0l4-4z" clip-rule="evenodd"/>
            </svg>
            <span>Selected: <strong id="selected-characteristic-name"></strong></span>
          </div>
        </div>
      </div>

    <!-- Chart Display Area -->
    <div id="custom-chart-container" class="bg-white rounded-lg p-6 border-2 border-gray-200 hidden">
      <div class="flex items-center justify-between mb-2">
        <div class="flex-1">
          <h3 id="custom-chart-title" class="text-lg font-bold text-gray-800"></h3>
          <p id="custom-chart-subtitle" class="text-sm text-gray-600 mt-1"></p>
        </div>
        <button
          id="clear-chart-btn"
          class="px-3 py-1 bg-gray-200 text-gray-700 rounded text-sm hover:bg-gray-300 transition-colors flex-shrink-0"
        >
          Clear
        </button>
      </div>
      <div class="relative" style="height: 400px;">
        <canvas id="custom-chart"></canvas>
      </div>
      <!-- Note for sites without data -->
      <div id="missing-sites-note" class="bg-gray-50 border-l-4 border-gray-400 p-3 rounded mt-4 hidden">
        <p class="text-sm text-gray-700">
          <strong>Sites without data:</strong> <span id="missing-sites-list"></span>
        </p>
      </div>
      <!-- Data Note - shown below chart only when 2025 data is included -->
      <div id="year-2025-note" class="bg-amber-50 border-l-4 border-amber-400 p-3 rounded mt-4 hidden">
        <p class="text-sm text-amber-800">
          <strong>Note:</strong> 2025 data represents a partial year and is not directly comparable to complete annual data from previous years.
        </p>
      </div>
    </div>

    <!-- Instructions (shown when no chart) -->
    <div id="chart-instructions" class="bg-gray-50 rounded-lg p-8 text-center">
      <svg class="w-16 h-16 mx-auto text-gray-400 mb-4" fill="none" stroke="currentColor" viewBox="0 0 24 24">
        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 19v-6a2 2 0 00-2-2H5a2 2 0 00-2 2v6a2 2 0 002 2h2a2 2 0 002-2zm0 0V9a2 2 0 012-2h2a2 2 0 012 2v10m-6 0a2 2 0 002 2h2a2 2 0 002-2m0 0V5a2 2 0 012-2h2a2 2 0 012 2v14a2 2 0 01-2 2h-2a2 2 0 01-2-2z"/>
      </svg>
      <h3 class="text-xl font-bold text-gray-700 mb-2">Create Your Custom Chart</h3>
      <p class="text-gray-600">
        Select a characteristic from the sidebar, choose a chart type and grouping option, then click "Generate Chart" to visualize your data.
      </p>
    </div>
    </div>
    </div>
  </div>

  <!-- Table View -->
  <div id="table-view" class="hidden">
    <!-- Table Header with Export Button -->
    <div class="flex items-center justify-between mb-4">
      <!-- Search Box -->
      <div class="flex-1 mr-4">
        <input
          type="text"
          id="table-search"
          placeholder="Search characteristics..."
          class="w-full px-4 py-2 border-2 border-gray-300 rounded-lg focus:border-clif-burgundy focus:ring-2 focus:ring-clif-burgundy focus:ring-opacity-50"
        />
      </div>

      <!-- Export Button -->
      <button
        id="export-data"
        class="flex items-center gap-2 px-4 py-2 bg-green-600 text-white rounded-lg font-semibold hover:bg-green-700 transition-colors whitespace-nowrap"
      >
        <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 10v6m0 0l-3-3m3 3l3-3m2 8H7a2 2 0 01-2-2V5a2 2 0 012-2h5.586a1 1 0 01.707.293l5.414 5.414a1 1 0 01.293.707V19a2 2 0 01-2 2z"/>
        </svg>
        Export CSV
      </button>
    </div>

    <!-- Data Table -->
    <div class="overflow-x-auto max-h-[600px] overflow-y-auto">
      <table id="data-table" class="w-full border-collapse">
        <thead class="bg-clif-burgundy text-white sticky top-0 z-10">
          <tr>
            <th class="px-4 py-3 text-left font-semibold bg-clif-burgundy">Characteristic</th>
            <th class="px-4 py-3 text-left font-semibold bg-clif-burgundy">Site</th>
            <th class="px-4 py-3 text-left font-semibold bg-clif-burgundy">Year</th>
            <th class="px-4 py-3 text-left font-semibold bg-clif-burgundy">Value</th>
          </tr>
        </thead>
        <tbody id="table-body" class="divide-y divide-gray-200 bg-white">
          <!-- Populated by JavaScript -->
        </tbody>
      </table>
    </div>
  </div>
</div>

<!-- JSON data storage -->
<script type="application/json" id="consortium-json-data" set:html={dataJson}></script>
<script type="application/json" id="overall-json-data" set:html={overallDataJson}></script>

<script>
  // Parse data from JSON script tags
  const consortiumData = JSON.parse(document.getElementById('consortium-json-data').textContent);
  const overallTableData = JSON.parse(document.getElementById('overall-json-data').textContent);

  // State management
  let selectedSites = [...consortiumData.allSites];
  let selectedYears = [...consortiumData.allYears];
  let currentView = 'charts';

  // Chart instances
  let charts = {};

  // Initialize on page load
  document.addEventListener('DOMContentLoaded', () => {
    initializeFilters();
    initializeViewToggle();
    initializeExport();
    updateDashboard();
  });

  function initializeFilters() {
    // Site filter
    const siteToggle = document.getElementById('site-filter-toggle');
    const siteDropdown = document.getElementById('site-filter-dropdown');
    const siteAll = document.getElementById('site-all');
    const siteCheckboxes = document.querySelectorAll('.site-checkbox:not(#site-all)');

    siteToggle?.addEventListener('click', (e) => {
      e.stopPropagation();
      siteDropdown?.classList.toggle('hidden');
      document.getElementById('year-filter-dropdown')?.classList.add('hidden');
    });

    siteAll?.addEventListener('change', (e) => {
      const checked = e.target.checked;
      siteCheckboxes.forEach(cb => cb.checked = checked);
      updateSelectedSites();
    });

    siteCheckboxes.forEach(cb => {
      cb.addEventListener('change', () => {
        updateSelectedSites();
      });
    });

    // Year filter
    const yearToggle = document.getElementById('year-filter-toggle');
    const yearDropdown = document.getElementById('year-filter-dropdown');
    const yearAll = document.getElementById('year-all');
    const yearCheckboxes = document.querySelectorAll('.year-checkbox:not(#year-all)');

    yearToggle?.addEventListener('click', (e) => {
      e.stopPropagation();
      yearDropdown?.classList.toggle('hidden');
      document.getElementById('site-filter-dropdown')?.classList.add('hidden');
    });

    yearAll?.addEventListener('change', (e) => {
      const checked = e.target.checked;
      yearCheckboxes.forEach(cb => cb.checked = checked);
      updateSelectedYears();
    });

    yearCheckboxes.forEach(cb => {
      cb.addEventListener('change', () => {
        updateSelectedYears();
      });
    });

    // Close dropdowns when clicking outside
    document.addEventListener('click', () => {
      siteDropdown?.classList.add('hidden');
      yearDropdown?.classList.add('hidden');
    });
  }

  function updateSelectedSites() {
    const checkboxes = document.querySelectorAll('.site-checkbox:not(#site-all)');
    selectedSites = Array.from(checkboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);

    const siteAll = document.getElementById('site-all');
    if (siteAll) {
      siteAll.checked = selectedSites.length === consortiumData.allSites.length;
    }

    let text;
    if (selectedSites.length === consortiumData.allSites.length) {
      text = 'All Sites';
    } else if (selectedSites.length === 1) {
      text = selectedSites[0];
    } else if (selectedSites.length <= 3) {
      text = selectedSites.join(', ');
    } else {
      text = `${selectedSites.length} Sites`;
    }
    document.getElementById('site-filter-text').textContent = text;

    updateDashboard();
  }

  function updateSelectedYears() {
    const checkboxes = document.querySelectorAll('.year-checkbox:not(#year-all)');
    selectedYears = Array.from(checkboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);

    const yearAll = document.getElementById('year-all');
    if (yearAll) {
      yearAll.checked = selectedYears.length === consortiumData.allYears.length;
    }

    let text;
    if (selectedYears.length === consortiumData.allYears.length) {
      text = 'All Years';
    } else if (selectedYears.length === 1) {
      text = selectedYears[0];
    } else if (selectedYears.length <= 3) {
      text = selectedYears.join(', ');
    } else {
      text = `${selectedYears.length} Years`;
    }
    document.getElementById('year-filter-text').textContent = text;

    updateDashboard();
  }

  function initializeViewToggle() {
    const chartsBtn = document.getElementById('view-charts');
    const tableBtn = document.getElementById('view-table');
    const chartsView = document.getElementById('charts-view');
    const tableView = document.getElementById('table-view');

    chartsBtn?.addEventListener('click', () => {
      currentView = 'charts';
      chartsBtn.classList.remove('bg-gray-200', 'text-gray-700');
      chartsBtn.classList.add('bg-clif-burgundy', 'text-white');
      tableBtn?.classList.remove('bg-clif-burgundy', 'text-white');
      tableBtn?.classList.add('bg-gray-200', 'text-gray-700');
      chartsView?.classList.remove('hidden');
      tableView?.classList.add('hidden');
    });

    tableBtn?.addEventListener('click', () => {
      currentView = 'table';
      tableBtn.classList.remove('bg-gray-200', 'text-gray-700');
      tableBtn.classList.add('bg-clif-burgundy', 'text-white');
      chartsBtn?.classList.remove('bg-clif-burgundy', 'text-white');
      chartsBtn?.classList.add('bg-gray-200', 'text-gray-700');
      tableView?.classList.remove('hidden');
      chartsView?.classList.add('hidden');
      updateTable();
    });

    // Table search
    const searchInput = document.getElementById('table-search');
    searchInput?.addEventListener('input', () => {
      updateTable();
    });
  }

  function initializeExport() {
    const exportBtn = document.getElementById('export-data');
    exportBtn?.addEventListener('click', exportToCSV);
  }

  function updateDashboard() {
    if (currentView === 'charts') {
      updateCharts();
    } else {
      updateTable();
    }
  }

  function getFilteredData() {
    return consortiumData.siteYearData.filter(d => {
      return selectedSites.includes(d.site) && selectedYears.includes(d.year);
    });
  }

  function extractNumber(value) {
    if (!value) return 0;
    const match = value.match(/^[\d,]+/);
    return match ? parseInt(match[0].replace(/,/g, ''), 10) : 0;
  }

  // Helper function to extract numeric value from string like "164 (0.1%)" or "68,359 (57.6%)" or "66 [54, 76]" or "3.0 [1.0, 6.0]"
  function getNumeric(value) {
    if (typeof value !== 'string') return null;

    // Match patterns:
    // "3.0 [1.0, 6.0]" -> extract 3.0
    // "164 (0.1%)" -> extract 164
    // "68,359 (57.6%)" -> extract 68359
    // Just extract the first number before any brackets or parentheses
    const match = value.match(/^\s*([-\d,\.]+)/);

    if (match) {
      const numStr = match[1].replace(/,/g, '');
      try {
        return parseFloat(numStr);
      } catch {
        return null;
      }
    }
    return null;
  }

  // Check if value has IQR pattern [x, y]
  function valueHasIQR(value) {
    if (typeof value !== 'string') return false;
    return /\[.*?,.*?\]/.test(value);
  }

  // Extract median and IQR from a value like "66 [54, 76]" or "3.0 [1.0, 6.0]"
  function extractMedianAndIQR(value) {
    if (typeof value !== 'string') return null;

    // Match pattern: number [number, number]
    const match = value.match(/^\s*([\d,\.]+)\s*\[\s*([\d,\.]+)\s*,\s*([\d,\.]+)\s*\]/);

    if (match) {
      return {
        median: parseFloat(match[1].replace(/,/g, '')),
        q1: parseFloat(match[2].replace(/,/g, '')),
        q3: parseFloat(match[3].replace(/,/g, ''))
      };
    }
    return null;
  }

  // Get weight for a site-year combination based on characteristic type
  // For "Age at admission", use "N: Unique patients"
  // For all other median characteristics, use "N: Hospitalizations"
  function getWeight(siteYearData, characteristic) {
    const isAgeAtAdmission = characteristic.trim().toLowerCase().includes('age at admission');
    const weightKey = isAgeAtAdmission ? 'N: Unique patients' : 'N: Hospitalizations';

    // Try exact match first
    let weightValue = siteYearData.characteristics[weightKey];

    // If not found, try to find by trimming
    if (!weightValue) {
      const charKey = Object.keys(siteYearData.characteristics).find(key =>
        key.trim() === weightKey
      );
      if (charKey) {
        weightValue = siteYearData.characteristics[charKey];
      }
    }

    // Extract numeric value from weight (e.g., "68,359 (57.6%)" -> 68359)
    if (weightValue) {
      const numMatch = weightValue.match(/^\s*([\d,]+)/);
      if (numMatch) {
        return parseInt(numMatch[1].replace(/,/g, ''), 10);
      }
    }

    return 0;
  }

  // Calculate weighted median from array of {value, weight} objects
  function calculateWeightedMedian(items) {
    if (items.length === 0) return null;
    if (items.length === 1) return items[0].value;

    // Sort by value
    const sorted = items.slice().sort((a, b) => a.value - b.value);

    // Calculate total weight
    const totalWeight = sorted.reduce((sum, item) => sum + item.weight, 0);

    // Find the median
    const halfWeight = totalWeight / 2;
    let cumulativeWeight = 0;

    for (let i = 0; i < sorted.length; i++) {
      cumulativeWeight += sorted[i].weight;
      if (cumulativeWeight >= halfWeight) {
        return sorted[i].value;
      }
    }

    return sorted[sorted.length - 1].value;
  }

  // Check if a value has n < 10 (for privacy protection)
  function hasSmallN(value) {
    if (typeof value !== 'string') return false;

    // Don't apply privacy filter to median/IQR values (they have brackets)
    if (valueHasIQR(value)) return false;

    // Extract the first numeric value (before parentheses or brackets)
    const numericMatch = value.match(/^\s*([\d,]+)/);
    if (numericMatch) {
      const num = parseInt(numericMatch[1].replace(/,/g, ''), 10);
      return num < 10;
    }

    return false;
  }

  // Check if value has "n (%)" format (categorical/proportion variables)
  function hasCountPercentageFormat(value) {
    if (typeof value !== 'string') return false;
    // Match pattern: number (percentage%)
    return /^\s*[\d,]+\s*\([^)]*%\)/.test(value);
  }

  // Parse "n (%)" format and extract both count and percentage
  // Example: "511,899 (63.3%)" -> { count: 511899, percentage: 63.3 }
  function parseCountPercentage(value) {
    if (typeof value !== 'string') return null;

    // Match pattern: "68,359 (57.6%)" or "164 (0.1%)"
    const match = value.match(/^\s*([\d,]+)\s*\(([^)]*?)%\)/);

    if (match) {
      return {
        count: parseInt(match[1].replace(/,/g, ''), 10),
        percentage: parseFloat(match[2])
      };
    }
    return null;
  }

  // Determine which category a characteristic belongs to
  function getCategoryForCharacteristic(characteristic) {
    const variable = characteristic.trim();

    // Demographics (uses N: Unique Patients as denominator)
    if (variable.includes('Age at admission') ||
        variable.includes('Race:') ||
        variable.includes('Ethnicity:') ||
        variable.includes('Sex:')) {
      return 'Demographics';
    }

    // All other categories use N: Hospitalizations as denominator
    return 'Other';
  }

  // Get total denominator for selected sites
  // Demographics use "N: Unique patients", others use "N: Hospitalizations"
  // For respiratory support, can optionally use IMV count as denominator
  function getTotalDenominator(category, filteredData, customDenominatorKey = null) {
    let denominatorKey = customDenominatorKey || (category === 'Demographics' ? 'N: Unique patients' : 'N: Hospitalizations');

    let total = 0;
    filteredData.forEach(d => {
      let denominatorValue = d.characteristics[denominatorKey];

      // Try trimmed match if exact match fails
      if (!denominatorValue) {
        const charKey = Object.keys(d.characteristics).find(key =>
          key.trim() === denominatorKey
        );
        if (charKey) {
          denominatorValue = d.characteristics[charKey];
        }
      }

      if (denominatorValue) {
        const numMatch = denominatorValue.match(/^\s*([\d,]+)/);
        if (numMatch) {
          total += parseInt(numMatch[1].replace(/,/g, ''), 10);
        }
      }
    });

    return total;
  }

  // Track selected characteristic
  let selectedCharacteristic = null;
  let selectedCharacteristicDataType = null; // 'count', 'percentage', or 'median'

  // Store IMV location types for the consolidated dropdown
  let imvLocationTypes = [];
  let imvLocationCharacteristics = {}; // Map location type to actual characteristic name

  // Store ventilator mode types for the consolidated dropdown
  let ventModeTypes = [];
  let ventModeCharacteristics = {}; // Map mode type to actual characteristic name

  // Store demographic types for consolidated dropdowns
  let ethnicityTypes = [];
  let ethnicityCharacteristics = {}; // Map ethnicity type to actual characteristic name
  let raceTypes = [];
  let raceCharacteristics = {}; // Map race type to actual characteristic name
  let sexTypes = [];
  let sexCharacteristics = {}; // Map sex type to actual characteristic name

  // Store encounter-related types for consolidated dropdowns
  let admissionTypeTypes = [];
  let admissionTypeCharacteristics = {}; // Map admission type to actual characteristic name
  let firstAdmissionLocationTypes = [];
  let firstAdmissionLocationCharacteristics = {}; // Map location type to actual characteristic name
  let encounterTypeTypes = [];
  let encounterTypeCharacteristics = {}; // Map encounter type to actual characteristic name

  // Detect the data type of a characteristic based on its values
  function detectCharacteristicDataType(characteristic) {
    // First check by name patterns
    const charTrimmed = characteristic.trim();

    // Count data - starts with "N:"
    if (charTrimmed.startsWith('N:')) {
      return 'count';
    }

    // Median data - contains "median" or "[Q1" in name
    if (charTrimmed.toLowerCase().includes('median') ||
        charTrimmed.toLowerCase().includes('[q1')) {
      return 'median';
    }

    // Check actual data values to determine type
    const allData = consortiumData.siteYearData;
    for (let i = 0; i < allData.length; i++) {
      let value = allData[i].characteristics[characteristic];

      // Try trimmed match if exact match fails
      if (!value) {
        const charKey = Object.keys(allData[i].characteristics).find(key =>
          key.trim() === characteristic.trim()
        );
        if (charKey) {
          value = allData[i].characteristics[charKey];
        }
      }

      if (value && value.trim() !== '') {
        // Check for IQR pattern: "66 [54, 76]"
        if (/\[.*?,.*?\]/.test(value)) {
          return 'median';
        }
        // Check for percentage pattern: "164 (0.1%)" or "68,359 (57.6%)"
        if (/^\s*[\d,]+\s*\([^)]*%\)/.test(value)) {
          return 'percentage';
        }
        // Otherwise it's a count
        return 'count';
      }
    }

    return 'count'; // Default fallback
  }

  // Get valid chart types based on data type and grouping
  function getValidChartTypes(dataType, groupBy) {
    // Check if this is a consolidated multi-type characteristic
    const isConsolidatedMultiType = selectedCharacteristic &&
      (selectedCharacteristic === '__IMV_LOCATION_CONSOLIDATED__' ||
       selectedCharacteristic === '__VENT_MODE_CONSOLIDATED__' ||
       selectedCharacteristic === '__ETHNICITY_CONSOLIDATED__' ||
       selectedCharacteristic === '__RACE_CONSOLIDATED__' ||
       selectedCharacteristic === '__SEX_CONSOLIDATED__' ||
       selectedCharacteristic === '__ADMISSION_TYPE_CONSOLIDATED__' ||
       selectedCharacteristic === '__FIRST_ADMISSION_LOCATION_CONSOLIDATED__' ||
       selectedCharacteristic === '__ENCOUNTER_TYPE_CONSOLIDATED__');

    // For consolidated multi-type items, offer stacked vs grouped bar options
    if (isConsolidatedMultiType) {
      const types = [
        { value: 'stacked', label: 'Stacked' },
        { value: 'grouped', label: 'Bar' }
      ];

      // Line chart: only for Year grouping (temporal trends)
      if (groupBy === 'year') {
        types.push({ value: 'line', label: 'Line' });
      }

      return types;
    }

    // Check if this is a SOFA score characteristic
    const isSOFAScore = selectedCharacteristic && (
      selectedCharacteristic.includes('Total SOFA score') ||
      selectedCharacteristic.includes('Respiratory, median') ||
      selectedCharacteristic.includes('Coagulation, median') ||
      selectedCharacteristic.includes('Liver, median') ||
      selectedCharacteristic.includes('Cardiovascular, median') ||
      selectedCharacteristic.includes('CNS, median') ||
      selectedCharacteristic.includes('Renal, median')
    );

    // For SOFA scores, only show Error Bar option
    if (isSOFAScore) {
      return [{ value: 'medianiqr', label: 'Error Bar' }];
    }

    // Default chart types for regular characteristics
    const types = [];

    // For median data, Error Bar is the default (first option)
    if (dataType === 'median') {
      types.push({ value: 'medianiqr', label: 'Error Bar' });
      types.push({ value: 'bar', label: 'Bar Chart' });
    } else {
      types.push({ value: 'bar', label: 'Bar Chart' });
    }

    // Line chart: only for Year grouping (temporal trends)
    if (groupBy === 'year') {
      types.push({ value: 'line', label: 'Line Chart' });
    }

    // Pie: only for Count data grouped by Site (shows contribution to total)
    if (dataType === 'count' && groupBy === 'site') {
      types.push({ value: 'pie', label: 'Pie Chart' });
    }

    return types;
  }

  // Track previous data type to detect changes
  let previousDataType = null;

  // Update the chart type dropdown based on current selections
  function updateChartTypeDropdown() {
    const chartTypeSelect = document.getElementById('chart-type-select');
    const groupBySelect = document.getElementById('chart-xaxis-select');

    if (!chartTypeSelect || !groupBySelect) return;

    const groupBy = groupBySelect.value;
    const dataType = selectedCharacteristicDataType || 'count';

    // Get valid chart types
    const validTypes = getValidChartTypes(dataType, groupBy);

    // Store current selection
    const currentValue = chartTypeSelect.value;

    // Rebuild dropdown options
    chartTypeSelect.innerHTML = '';
    validTypes.forEach(type => {
      const option = document.createElement('option');
      option.value = type.value;
      option.textContent = type.label;
      chartTypeSelect.appendChild(option);
    });

    // Check if data type changed - if so, reset to new default
    const dataTypeChanged = previousDataType !== null && previousDataType !== dataType;
    previousDataType = dataType;

    if (dataTypeChanged) {
      // Data type changed, use the new default (first option)
      chartTypeSelect.value = validTypes[0]?.value || 'bar';
    } else {
      // Try to preserve current selection if still valid
      const isCurrentValid = validTypes.some(t => t.value === currentValue);
      if (isCurrentValid) {
        chartTypeSelect.value = currentValue;
      } else {
        // Default to first available option
        chartTypeSelect.value = validTypes[0]?.value || 'bar';
      }
    }
  }

  function initializeChartBuilder() {
    // Build the category sidebar
    buildCategorySidebar();

    // Generate chart button
    const generateBtn = document.getElementById('generate-chart-btn');
    generateBtn?.addEventListener('click', generateCustomChart);

    // Clear chart button
    const clearBtn = document.getElementById('clear-chart-btn');
    clearBtn?.addEventListener('click', clearCustomChart);

    // Characteristic search
    const searchInput = document.getElementById('characteristic-search');
    searchInput?.addEventListener('input', (e) => {
      filterCategorySidebar(e.target.value);
    });

    // Group By dropdown - update chart types when changed
    const groupBySelect = document.getElementById('chart-xaxis-select');
    groupBySelect?.addEventListener('change', () => {
      updateChartTypeDropdown();
    });

    // Chart Type dropdown - show/hide denominator selector based on selection
    const chartTypeSelect = document.getElementById('chart-type-select');
    chartTypeSelect?.addEventListener('change', () => {
      updateDenominatorSelectorVisibility();
    });

    // Initialize chart type dropdown with default options
    updateChartTypeDropdown();
  }

  // Show/hide denominator selector based on chart type for consolidated items
  function updateDenominatorSelectorVisibility() {
    const respDenomSelector = document.getElementById('resp-denominator-selector');

    if (!respDenomSelector) return;

    // Check if this is a consolidated respiratory support item
    const isRespConsolidated = selectedCharacteristic === '__IMV_LOCATION_CONSOLIDATED__' ||
                               selectedCharacteristic === '__VENT_MODE_CONSOLIDATED__';

    // Always hide denominator selector for consolidated items - they always use IMV as denominator
    if (isRespConsolidated) {
      respDenomSelector.classList.add('hidden');
    }
  }

  function buildCategorySidebar() {
    // Use ALL data for sidebar, not filtered data
    // The sidebar should show all available characteristics regardless of filter selection
    const allData = consortiumData.siteYearData;

    // Get all characteristics, excluding header/placeholder rows and metadata
    const characteristics = new Set();
    const headerPatterns = [
      'Neuromuscular blocking agents, n (%)',
      'Sedatives and analgesics, n (%)',
      'SOFA Scores',
      'Comorbidities, n (%)',
      'Encounter Types',
      'Vasopressor encounters, n (%)',
      'N: Hospitals' // Exclude hospitals count - it's metadata, not a patient characteristic
    ];

    allData.forEach(d => {
      Object.keys(d.characteristics).forEach(char => {
        // Skip if it's a header/placeholder row
        if (!headerPatterns.includes(char.trim())) {
          characteristics.add(char);
        }
      });
    });

    // Group characteristics by category with subcategory support
    // Structure: { categoryName: { items: [], subcategories: { subName: [] } } }
    const categories = {
      'Population': { items: [], subcategories: {} },
      'Demographics': { items: [], subcategories: {} },
      'Encounter Information': {
        items: [],
        subcategories: {
          'Encounter Types': []
        }
      },
      'Clinical Outcomes': { items: [], subcategories: {} },
      'Comorbidities': { items: [], subcategories: {} },
      'Severity Scores': {
        items: [],
        subcategories: {
          'SOFA Scores': []
        }
      },
      'Respiratory Support': { items: [], subcategories: {} },
      'Renal Support': { items: [], subcategories: {} },
      'Medications': {
        items: [],
        subcategories: {
          'Neuromuscular blocking agents': [],
          'Sedatives and analgesics': [],
          'Vasopressors': []
        }
      },
      'Other': { items: [], subcategories: {} }
    };

    characteristics.forEach(char => {
      const charTrimmed = char.trim();
      const charOriginal = char; // Keep original with spaces
      let categorized = false;

      // Severity Scores - SOFA Scores subcategory - HARDCODED exact matches from CSV
      if (charTrimmed === 'Total SOFA score, median [Q1, Q3]' ||
          charTrimmed === 'Respiratory, median [Q1, Q3]' ||
          charTrimmed === 'Coagulation, median [Q1, Q3]' ||
          charTrimmed === 'Liver, median [Q1, Q3]' ||
          charTrimmed === 'Cardiovascular, median [Q1, Q3]' ||
          charTrimmed === 'CNS, median [Q1, Q3]' ||
          charTrimmed === 'Renal, median [Q1, Q3]') {
        categories['Severity Scores'].subcategories['SOFA Scores'].push(charOriginal); // Keep original with leading spaces for data lookup
        categorized = true;
      }
      // P/F ratios are separate from SOFA scores
      else if (charTrimmed === 'P/F ratio, median [Q1, Q3]' ||
               charTrimmed === 'P/F ratio (imputed), median [Q1, Q3]') {
        categories['Severity Scores'].items.push(charOriginal);
        categorized = true;
      }
      // Demographics - Age at admission stays as regular item
      else if (charTrimmed.includes('Age at admission')) {
        categories['Demographics'].items.push(charTrimmed);
        categorized = true;
      }
      // Demographics - handle "Ethnicity:" specially for consolidated dropdown
      else if (charTrimmed.startsWith('Ethnicity:')) {
        const ethnicityType = charTrimmed.replace('Ethnicity:', '').trim();
        if (ethnicityType) {
          ethnicityCharacteristics[ethnicityType] = charTrimmed;
          if (!ethnicityTypes.includes(ethnicityType)) {
            ethnicityTypes.push(ethnicityType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Demographics - handle "Race:" specially for consolidated dropdown
      else if (charTrimmed.startsWith('Race:')) {
        const raceType = charTrimmed.replace('Race:', '').trim();
        if (raceType) {
          raceCharacteristics[raceType] = charTrimmed;
          if (!raceTypes.includes(raceType)) {
            raceTypes.push(raceType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Demographics - handle "Sex:" specially for consolidated dropdown
      else if (charTrimmed.startsWith('Sex:')) {
        const sexType = charTrimmed.replace('Sex:', '').trim();
        if (sexType) {
          sexCharacteristics[sexType] = charTrimmed;
          if (!sexTypes.includes(sexType)) {
            sexTypes.push(sexType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Encounter Information - handle "Admission type:" specially for consolidated dropdown
      else if (charTrimmed.startsWith('Admission type:')) {
        const admType = charTrimmed.replace('Admission type:', '').trim();
        if (admType) {
          admissionTypeCharacteristics[admType] = charTrimmed;
          if (!admissionTypeTypes.includes(admType)) {
            admissionTypeTypes.push(admType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Encounter Information - handle "First admission location:" specially for consolidated dropdown
      else if (charTrimmed.startsWith('First admission location:')) {
        const locType = charTrimmed.replace('First admission location:', '').trim();
        if (locType) {
          firstAdmissionLocationCharacteristics[locType] = charTrimmed;
          if (!firstAdmissionLocationTypes.includes(locType)) {
            firstAdmissionLocationTypes.push(locType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Encounter Information - handle encounter types specially for consolidated dropdown
      else if (charTrimmed.includes('ICU encounters') ||
               charTrimmed.includes('Advanced respiratory support') ||
               charTrimmed.includes('Vasoactive support') ||
               charTrimmed.includes('Other critically ill')) {
        // Extract the encounter type name
        const encType = charTrimmed.replace(', n (%)', '').trim();
        if (encType) {
          encounterTypeCharacteristics[encType] = charTrimmed;
          if (!encounterTypeTypes.includes(encType)) {
            encounterTypeTypes.push(encType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Clinical Outcomes
      else if (charTrimmed.includes('Hospital mortality') ||
               charTrimmed.includes('Discharged to hospice') ||
               charTrimmed.includes('Expired') ||
               charTrimmed.includes('length of stay')) {
        categories['Clinical Outcomes'].items.push(charTrimmed);
        categorized = true;
      }
      // Comorbidities
      else if (charTrimmed.includes('Charlson') ||
               charTrimmed.includes('Comorbidities') ||
               charTrimmed.includes('Heart Failure') ||
               charTrimmed.includes('Renal Disease') ||
               charTrimmed.includes('Pulmonary Disease') ||
               charTrimmed.includes('Cerebrovascular') ||
               charTrimmed.includes('Cancer') ||
               charTrimmed.includes('Metastatic') ||
               charTrimmed.includes('Vascular Disease') ||
               charTrimmed.includes('Myocardial') ||
               charTrimmed.includes('Dementia') ||
               charTrimmed.includes('Liver Disease') ||
               charTrimmed.includes('Hemiplegia') ||
               charTrimmed.includes('Connective Tissue') ||
               charTrimmed.includes('Peptic Ulcer') ||
               charTrimmed.includes('Aids')) {
        categories['Comorbidities'].items.push(charTrimmed);
        categorized = true;
      }
      // Respiratory Support - handle "First location at IMV start" specially
      else if (charTrimmed.startsWith('First location at IMV start:')) {
        // Extract the location type (e.g., "ed", "icu", "ward", etc.)
        const locationType = charTrimmed.replace('First location at IMV start:', '').trim();
        // Exclude "dialysis" from location types (very low counts across sites)
        if (locationType && locationType.toLowerCase() !== 'dialysis') {
          imvLocationCharacteristics[locationType] = charTrimmed;
          if (!imvLocationTypes.includes(locationType)) {
            imvLocationTypes.push(locationType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Respiratory Support - handle "Initial ventilator mode:" specially
      else if (charTrimmed.startsWith('Initial ventilator mode:')) {
        // Extract the mode type (e.g., "assist control-volume control", "simv", etc.)
        const modeType = charTrimmed.replace('Initial ventilator mode:', '').trim();
        if (modeType) {
          ventModeCharacteristics[modeType] = charTrimmed;
          if (!ventModeTypes.includes(modeType)) {
            ventModeTypes.push(modeType);
          }
        }
        categorized = true; // Don't add to sidebar - we'll add a consolidated entry
      }
      // Other Respiratory Support items
      else if (charTrimmed.includes('mechanical ventilation') ||
               charTrimmed.includes('IMV') ||
               charTrimmed.includes('FiO2') ||
               charTrimmed.includes('PEEP') ||
               charTrimmed.includes('Respiratory rate') ||
               charTrimmed.includes('Tidal volume')) {
        categories['Respiratory Support'].items.push(charTrimmed);
        categorized = true;
      }
      // Renal Support
      else if (charTrimmed.includes('CRRT')) {
        categories['Renal Support'].items.push(charTrimmed);
        categorized = true;
      }
      // Medications with subcategories
      else if (charTrimmed.includes('Cisatracurium') ||
               charTrimmed.includes('Rocuronium')) {
        categories['Medications'].subcategories['Neuromuscular blocking agents'].push(charTrimmed);
        categorized = true;
      }
      else if (charTrimmed.includes('Propofol') ||
               charTrimmed.includes('Midazolam') ||
               charTrimmed.includes('Lorazepam') ||
               charTrimmed.includes('Dexmedetomidine') ||
               charTrimmed.includes('Fentanyl')) {
        categories['Medications'].subcategories['Sedatives and analgesics'].push(charTrimmed);
        categorized = true;
      }
      // Vasopressors - moved from Cardiovascular Support to Medications
      else if (charTrimmed.includes('Norepinephrine') ||
               charTrimmed.includes('Epinephrine') ||
               charTrimmed.includes('Phenylephrine') ||
               charTrimmed.includes('Vasopressin') ||
               charTrimmed.includes('Dopamine') ||
               charTrimmed.includes('Dobutamine')) {
        categories['Medications'].subcategories['Vasopressors'].push(charTrimmed);
        categorized = true;
      }
      // Population - exclude "N: Hospitals" as it's metadata, not a meaningful characteristic
      else if (charTrimmed.startsWith('N:') && !charTrimmed.includes('Hospitals')) {
        categories['Population'].items.push(charTrimmed);
        categorized = true;
      }

      if (!categorized) {
        categories['Other'].items.push(charTrimmed);
      }
    });

    // Add consolidated "First location at IMV start" entry if we have location types
    if (imvLocationTypes.length > 0) {
      // Sort location types alphabetically
      imvLocationTypes.sort();
      // Add a special marker for the consolidated entry
      categories['Respiratory Support'].items.push('__IMV_LOCATION_CONSOLIDATED__');
    }

    // Add consolidated "Initial ventilator mode" entry if we have mode types
    if (ventModeTypes.length > 0) {
      // Sort mode types alphabetically
      ventModeTypes.sort();
      // Add a special marker for the consolidated entry
      categories['Respiratory Support'].items.push('__VENT_MODE_CONSOLIDATED__');
    }

    // Add consolidated "Ethnicity" entry if we have ethnicity types
    if (ethnicityTypes.length > 0) {
      ethnicityTypes.sort();
      categories['Demographics'].items.push('__ETHNICITY_CONSOLIDATED__');
    }

    // Add consolidated "Race" entry if we have race types
    if (raceTypes.length > 0) {
      raceTypes.sort();
      categories['Demographics'].items.push('__RACE_CONSOLIDATED__');
    }

    // Add consolidated "Sex" entry if we have sex types
    if (sexTypes.length > 0) {
      sexTypes.sort();
      categories['Demographics'].items.push('__SEX_CONSOLIDATED__');
    }

    // Add consolidated "Admission type" entry if we have admission types
    if (admissionTypeTypes.length > 0) {
      admissionTypeTypes.sort();
      categories['Encounter Information'].items.push('__ADMISSION_TYPE_CONSOLIDATED__');
    }

    // Add consolidated "First admission location" entry if we have location types
    if (firstAdmissionLocationTypes.length > 0) {
      firstAdmissionLocationTypes.sort();
      categories['Encounter Information'].items.push('__FIRST_ADMISSION_LOCATION_CONSOLIDATED__');
    }

    // Add consolidated "Encounter type" entry if we have encounter types
    if (encounterTypeTypes.length > 0) {
      encounterTypeTypes.sort();
      categories['Encounter Information'].items.push('__ENCOUNTER_TYPE_CONSOLIDATED__');
    }

    // Build the sidebar HTML
    const categoriesList = document.getElementById('categories-list');
    if (!categoriesList) return;

    categoriesList.innerHTML = '';

    Object.entries(categories).forEach(([categoryName, categoryData]) => {
      const hasItems = categoryData.items.length > 0;
      const hasSubcategories = Object.keys(categoryData.subcategories).length > 0;

      if (!hasItems && !hasSubcategories) return; // Skip empty categories

      const categoryDiv = document.createElement('div');
      categoryDiv.className = 'category-section border-b border-gray-200';

      // Category header (collapsible)
      const header = document.createElement('button');
      header.className = 'category-header w-full flex items-center justify-between p-3 hover:bg-gray-50 transition-colors text-left';
      header.innerHTML = `
        <span class="font-semibold text-gray-800 text-sm">${categoryName}</span>
        <svg class="chevron w-4 h-4 text-gray-500 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
          <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
        </svg>
      `;

      // Characteristics list container
      const charList = document.createElement('div');
      charList.className = 'characteristic-list';
      charList.style.display = 'none'; // Start collapsed

      // Add top-level items first
      categoryData.items.sort().forEach(char => {
        const charItem = document.createElement('button');
        charItem.className = 'characteristic-item w-full text-left px-4 py-2 text-sm text-gray-700 hover:bg-clif-burgundy hover:bg-opacity-10 hover:text-clif-burgundy transition-colors';

        // Handle consolidated IMV location entry specially
        if (char === '__IMV_LOCATION_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__IMV_LOCATION_CONSOLIDATED__';
          charItem.textContent = 'First location at IMV start';
          charItem.addEventListener('click', () => selectIMVLocationCharacteristic(charItem));
        }
        // Handle consolidated ventilator mode entry specially
        else if (char === '__VENT_MODE_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__VENT_MODE_CONSOLIDATED__';
          charItem.textContent = 'Initial ventilator mode';
          charItem.addEventListener('click', () => selectVentModeCharacteristic(charItem));
        }
        // Handle consolidated ethnicity entry specially
        else if (char === '__ETHNICITY_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__ETHNICITY_CONSOLIDATED__';
          charItem.textContent = 'Ethnicity';
          charItem.addEventListener('click', () => selectEthnicityCharacteristic(charItem));
        }
        // Handle consolidated race entry specially
        else if (char === '__RACE_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__RACE_CONSOLIDATED__';
          charItem.textContent = 'Race';
          charItem.addEventListener('click', () => selectRaceCharacteristic(charItem));
        }
        // Handle consolidated sex entry specially
        else if (char === '__SEX_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__SEX_CONSOLIDATED__';
          charItem.textContent = 'Sex';
          charItem.addEventListener('click', () => selectSexCharacteristic(charItem));
        }
        // Handle consolidated admission type entry specially
        else if (char === '__ADMISSION_TYPE_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__ADMISSION_TYPE_CONSOLIDATED__';
          charItem.textContent = 'Admission type';
          charItem.addEventListener('click', () => selectAdmissionTypeCharacteristic(charItem));
        }
        // Handle consolidated first admission location entry specially
        else if (char === '__FIRST_ADMISSION_LOCATION_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__FIRST_ADMISSION_LOCATION_CONSOLIDATED__';
          charItem.textContent = 'First admission location';
          charItem.addEventListener('click', () => selectFirstAdmissionLocationCharacteristic(charItem));
        }
        // Handle consolidated encounter type entry specially
        else if (char === '__ENCOUNTER_TYPE_CONSOLIDATED__') {
          charItem.dataset.characteristic = '__ENCOUNTER_TYPE_CONSOLIDATED__';
          charItem.textContent = 'Encounter type';
          charItem.addEventListener('click', () => selectEncounterTypeCharacteristic(charItem));
        } else {
          charItem.dataset.characteristic = char; // Keep original with spaces for data lookup
          charItem.textContent = char.trim(); // Display trimmed version
          charItem.addEventListener('click', () => selectCharacteristic(char, charItem)); // Pass original
        }
        charList.appendChild(charItem);
      });

      // Add subcategories
      Object.entries(categoryData.subcategories).forEach(([subName, subItems]) => {
        if (subItems.length === 0) return; // Skip empty subcategories

        // Subcategory container
        const subDiv = document.createElement('div');
        subDiv.className = 'subcategory-section border-l-2 border-gray-300 ml-2';

        // Subcategory header (collapsible)
        const subHeader = document.createElement('button');
        subHeader.className = 'subcategory-header w-full flex items-center justify-between px-3 py-2 hover:bg-gray-50 transition-colors text-left';
        subHeader.innerHTML = `
          <span class="font-medium text-gray-700 text-xs">${subName}</span>
          <svg class="sub-chevron w-3 h-3 text-gray-400 transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path>
          </svg>
        `;

        // Subcategory items list
        const subItemsList = document.createElement('div');
        subItemsList.className = 'subcategory-items';
        subItemsList.style.display = 'none'; // Start collapsed

        subItems.sort().forEach(char => {
          const charItem = document.createElement('button');
          charItem.className = 'characteristic-item w-full text-left pl-6 pr-4 py-2 text-sm text-gray-700 hover:bg-clif-burgundy hover:bg-opacity-10 hover:text-clif-burgundy transition-colors';
          charItem.dataset.characteristic = char;
          charItem.textContent = char.trim();
          charItem.addEventListener('click', () => selectCharacteristic(char, charItem));
          subItemsList.appendChild(charItem);
        });

        // Set initial subcategory chevron to collapsed state
        const subChevron = subHeader.querySelector('.sub-chevron');
        if (subChevron) {
          subChevron.style.transform = 'rotate(-90deg)';
        }

        // Toggle subcategory collapse on header click
        subHeader.addEventListener('click', () => {
          const isExpanded = subItemsList.style.display !== 'none';
          subItemsList.style.display = isExpanded ? 'none' : 'block';
          subHeader.querySelector('.sub-chevron').style.transform = isExpanded ? 'rotate(-90deg)' : 'rotate(0deg)';
        });

        subDiv.appendChild(subHeader);
        subDiv.appendChild(subItemsList);
        charList.appendChild(subDiv);
      });

      // Set initial chevron to collapsed state
      const chevron = header.querySelector('.chevron');
      if (chevron) {
        chevron.style.transform = 'rotate(-90deg)';
      }

      // Toggle collapse on header click
      header.addEventListener('click', () => {
        const isExpanded = charList.style.display !== 'none';
        charList.style.display = isExpanded ? 'none' : 'block';
        header.querySelector('.chevron').style.transform = isExpanded ? 'rotate(-90deg)' : 'rotate(0deg)';
      });

      categoryDiv.appendChild(header);
      categoryDiv.appendChild(charList);
      categoriesList.appendChild(categoryDiv);
    });
  }

  function selectCharacteristic(characteristic, element) {
    selectedCharacteristic = characteristic;

    // Detect data type and update chart type dropdown
    selectedCharacteristicDataType = detectCharacteristicDataType(characteristic);
    updateChartTypeDropdown();

    // Update UI - remove previous selection
    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });

    // Highlight selected item
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    // Show selected characteristic
    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = characteristic.trim(); // Display trimmed version
      display.classList.remove('hidden');
    }

    // Show/hide respiratory support denominator selector
    const respDenomSelector = document.getElementById('resp-denominator-selector');
    if (respDenomSelector) {
      const charTrimmed = characteristic.trim().toLowerCase();

      // Check if this is the IMV count variable itself (not other IMV-related variables)
      // For "Invasive mechanical ventilation, n (%)", the IMV denominator doesn't make sense
      // because IMV/IMV = 100% always. Only show selector for OTHER respiratory variables.
      const isIMVCountVariable = charTrimmed.startsWith('invasive mechanical ventilation');

      const isRespSupport = charTrimmed.includes('mechanical ventilation') ||
                           charTrimmed.includes('imv') ||
                           charTrimmed.includes('fio2') ||
                           charTrimmed.includes('peep') ||
                           charTrimmed.includes('ventilator mode') ||
                           charTrimmed.includes('respiratory rate') ||
                           charTrimmed.includes('tidal volume') ||
                           charTrimmed.includes('location at imv');
      const isMedian = charTrimmed.includes('median');

      // Show denominator selector only for non-median respiratory support variables
      // BUT NOT for "Invasive mechanical ventilation" itself (IMV/IMV = 100% is meaningless)
      if (isRespSupport && !isMedian && !isIMVCountVariable) {
        respDenomSelector.classList.remove('hidden');
      } else {
        respDenomSelector.classList.add('hidden');
      }
    }

    // Enable generate button
    const generateBtn = document.getElementById('generate-chart-btn');
    if (generateBtn) {
      generateBtn.disabled = false;
    }

    // Hide location type selector for non-IMV characteristics
    const locationSelector = document.getElementById('location-type-selector');
    if (locationSelector) {
      locationSelector.classList.add('hidden');
    }

    // Hide vent mode type selector for non-vent-mode characteristics
    const ventModeSelector = document.getElementById('vent-mode-type-selector');
    if (ventModeSelector) {
      ventModeSelector.classList.add('hidden');
    }

    // Hide demographic type selectors for non-demographic characteristics
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');

    // Hide encounter type selectors for non-encounter characteristics
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');
  }

  // Track selected location types for multi-select
  let selectedLocationTypes = [];
  let locationDropdownInitialized = false;

  // Special handler for the consolidated "First location at IMV start" item
  function selectIMVLocationCharacteristic(element) {
    // Set a special marker for this selection
    selectedCharacteristic = '__IMV_LOCATION_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    // Update UI - remove previous selection
    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });

    // Highlight selected item
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    // Show selected characteristic
    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'First location at IMV start';
      display.classList.remove('hidden');
    }

    // Show location type selector and populate checkboxes
    const locationSelector = document.getElementById('location-type-selector');
    const locationOptionsContainer = document.getElementById('location-options-container');
    const locationToggle = document.getElementById('location-type-toggle');
    const locationDropdown = document.getElementById('location-type-dropdown');
    const locationAll = document.getElementById('location-all');

    if (locationSelector && locationOptionsContainer) {
      // Populate checkboxes with available location types
      locationOptionsContainer.innerHTML = '';
      imvLocationTypes.forEach(locType => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        label.innerHTML = `
          <input
            type="checkbox"
            class="location-checkbox location-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
            value="${locType}"
            checked
          />
          <span class="ml-2 text-sm text-gray-700">${locType.charAt(0).toUpperCase() + locType.slice(1)}</span>
        `;
        locationOptionsContainer.appendChild(label);
      });

      // Initialize: no locations selected - let user choose
      selectedLocationTypes = [];
      locationAll.checked = false;
      const locationTextEl = document.getElementById('location-type-text');
      if (locationTextEl) locationTextEl.textContent = 'Select Types';

      // Only add event listeners once to prevent duplicate handlers
      if (!locationDropdownInitialized) {
        // Set up toggle button
        locationToggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          locationDropdown?.classList.toggle('hidden');
        });

        // Set up "All Locations" checkbox
        locationAll?.addEventListener('change', (e) => {
          const checked = e.target.checked;
          document.querySelectorAll('.location-type-checkbox').forEach(cb => {
            cb.checked = checked;
          });
          updateSelectedLocationTypes();
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!locationSelector.contains(e.target)) {
            locationDropdown?.classList.add('hidden');
          }
        });

        locationDropdownInitialized = true;
      }

      // Set up individual location checkboxes (these are created dynamically, so need to be set up each time)
      locationOptionsContainer.querySelectorAll('.location-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => {
          updateSelectedLocationTypes();
        });
      });

      locationSelector.classList.remove('hidden');
    }

    // Hide vent mode type selector (it's for vent modes, not IMV locations)
    const ventModeSelector = document.getElementById('vent-mode-type-selector');
    if (ventModeSelector) {
      ventModeSelector.classList.add('hidden');
    }

    // Hide demographic selectors
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');

    // Hide encounter selectors
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');

    // Hide respiratory support denominator selector (stacked distribution charts don't use it)
    // The denominator selector is for single-variable charts, not stacked distributions
    const respDenomSelector = document.getElementById('resp-denominator-selector');
    if (respDenomSelector) {
      respDenomSelector.classList.add('hidden');
    }

    // Update chart type dropdown
    updateChartTypeDropdown();

    // Enable generate button
    const generateBtn = document.getElementById('generate-chart-btn');
    if (generateBtn) {
      generateBtn.disabled = false;
    }
  }

  // Update selected location types and display text
  function updateSelectedLocationTypes() {
    const checkboxes = document.querySelectorAll('.location-type-checkbox');
    selectedLocationTypes = Array.from(checkboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);

    const locationAll = document.getElementById('location-all');
    if (locationAll) {
      locationAll.checked = selectedLocationTypes.length === imvLocationTypes.length;
    }

    // Update display text
    const textEl = document.getElementById('location-type-text');
    if (textEl) {
      if (selectedLocationTypes.length === imvLocationTypes.length) {
        textEl.textContent = 'All Locations';
      } else if (selectedLocationTypes.length === 0) {
        textEl.textContent = 'Select locations...';
      } else if (selectedLocationTypes.length === 1) {
        textEl.textContent = selectedLocationTypes[0].charAt(0).toUpperCase() + selectedLocationTypes[0].slice(1);
      } else if (selectedLocationTypes.length <= 2) {
        textEl.textContent = selectedLocationTypes.map(l => l.charAt(0).toUpperCase() + l.slice(1)).join(', ');
      } else {
        textEl.textContent = `${selectedLocationTypes.length} Locations`;
      }
    }
  }

  // Track selected ventilator mode types for multi-select
  let selectedVentModeTypes = [];
  let ventModeDropdownInitialized = false;

  // Special handler for the consolidated "Initial ventilator mode" item
  function selectVentModeCharacteristic(element) {
    // Set a special marker for this selection
    selectedCharacteristic = '__VENT_MODE_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    // Update UI - remove previous selection
    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });

    // Highlight selected item
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    // Show selected characteristic
    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Initial ventilator mode';
      display.classList.remove('hidden');
    }

    // Hide location type selector (it's for IMV location, not vent modes)
    const locationSelector = document.getElementById('location-type-selector');
    if (locationSelector) {
      locationSelector.classList.add('hidden');
    }

    // Hide demographic selectors
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');

    // Hide encounter selectors
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');

    // Show ventilator mode type selector and populate checkboxes
    const ventModeSelector = document.getElementById('vent-mode-type-selector');
    const ventModeOptionsContainer = document.getElementById('vent-mode-options-container');
    const ventModeToggle = document.getElementById('vent-mode-type-toggle');
    const ventModeDropdown = document.getElementById('vent-mode-type-dropdown');
    const ventModeAll = document.getElementById('vent-mode-all');

    if (ventModeSelector && ventModeOptionsContainer) {
      // Populate checkboxes with available ventilator mode types
      ventModeOptionsContainer.innerHTML = '';
      ventModeTypes.forEach(modeType => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        // Capitalize first letter of each word for display
        const displayName = modeType.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input
            type="checkbox"
            class="vent-mode-checkbox vent-mode-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy"
            value="${modeType}"
            checked
          />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        ventModeOptionsContainer.appendChild(label);
      });

      // Initialize: no modes selected - let user choose
      selectedVentModeTypes = [];
      ventModeAll.checked = false;
      const ventModeTextEl = document.getElementById('vent-mode-type-text');
      if (ventModeTextEl) ventModeTextEl.textContent = 'Select Types';

      // Only add event listeners once to prevent duplicate handlers
      if (!ventModeDropdownInitialized) {
        // Set up toggle button
        ventModeToggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          ventModeDropdown?.classList.toggle('hidden');
        });

        // Set up "All Modes" checkbox
        ventModeAll?.addEventListener('change', (e) => {
          const checked = e.target.checked;
          document.querySelectorAll('.vent-mode-type-checkbox').forEach(cb => {
            cb.checked = checked;
          });
          updateSelectedVentModeTypes();
        });

        // Close dropdown when clicking outside
        document.addEventListener('click', (e) => {
          if (!ventModeSelector.contains(e.target)) {
            ventModeDropdown?.classList.add('hidden');
          }
        });

        ventModeDropdownInitialized = true;
      }

      // Set up individual mode checkboxes (these are created dynamically, so need to be set up each time)
      ventModeOptionsContainer.querySelectorAll('.vent-mode-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => {
          updateSelectedVentModeTypes();
        });
      });

      ventModeSelector.classList.remove('hidden');
    }

    // Hide respiratory support denominator selector (stacked distribution charts don't use it)
    // The denominator selector is for single-variable charts, not stacked distributions
    const respDenomSelector = document.getElementById('resp-denominator-selector');
    if (respDenomSelector) {
      respDenomSelector.classList.add('hidden');
    }

    // Update chart type dropdown
    updateChartTypeDropdown();

    // Enable generate button
    const generateBtn = document.getElementById('generate-chart-btn');
    if (generateBtn) {
      generateBtn.disabled = false;
    }
  }

  // Update selected ventilator mode types and display text
  function updateSelectedVentModeTypes() {
    const checkboxes = document.querySelectorAll('.vent-mode-type-checkbox');
    selectedVentModeTypes = Array.from(checkboxes)
      .filter(cb => cb.checked)
      .map(cb => cb.value);

    const ventModeAll = document.getElementById('vent-mode-all');
    if (ventModeAll) {
      ventModeAll.checked = selectedVentModeTypes.length === ventModeTypes.length;
    }

    // Update display text
    const textEl = document.getElementById('vent-mode-type-text');
    if (textEl) {
      if (selectedVentModeTypes.length === ventModeTypes.length) {
        textEl.textContent = 'All Modes';
      } else if (selectedVentModeTypes.length === 0) {
        textEl.textContent = 'Select modes...';
      } else if (selectedVentModeTypes.length === 1) {
        const displayName = selectedVentModeTypes[0].split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        textEl.textContent = displayName;
      } else if (selectedVentModeTypes.length <= 2) {
        textEl.textContent = selectedVentModeTypes.map(m => m.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ')).join(', ');
      } else {
        textEl.textContent = `${selectedVentModeTypes.length} Modes`;
      }
    }
  }

  // Track selected demographic types for multi-select
  let selectedEthnicityTypes = [];
  let ethnicityDropdownInitialized = false;
  let selectedRaceTypes = [];
  let raceDropdownInitialized = false;
  let selectedSexTypes = [];
  let sexDropdownInitialized = false;

  // Helper function to hide all demographic selectors
  function hideAllDemographicSelectors() {
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
  }

  // Special handler for the consolidated "Ethnicity" item
  function selectEthnicityCharacteristic(element) {
    selectedCharacteristic = '__ETHNICITY_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    // Update UI - remove previous selection
    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    // Show selected characteristic
    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Ethnicity';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    // Show ethnicity type selector
    const selector = document.getElementById('ethnicity-type-selector');
    const optionsContainer = document.getElementById('ethnicity-options-container');
    const toggle = document.getElementById('ethnicity-type-toggle');
    const dropdown = document.getElementById('ethnicity-type-dropdown');
    const allCheckbox = document.getElementById('ethnicity-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      ethnicityTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input type="checkbox" class="ethnicity-checkbox ethnicity-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedEthnicityTypes = [...ethnicityTypes];
      allCheckbox.checked = true;

      if (!ethnicityDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.ethnicity-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedEthnicityTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        ethnicityDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.ethnicity-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedEthnicityTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedEthnicityTypes() {
    selectedEthnicityTypes = Array.from(document.querySelectorAll('.ethnicity-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('ethnicity-all');
    if (allCheckbox) allCheckbox.checked = selectedEthnicityTypes.length === ethnicityTypes.length;
    const textEl = document.getElementById('ethnicity-type-text');
    if (textEl) {
      if (selectedEthnicityTypes.length === ethnicityTypes.length) textEl.textContent = 'All Types';
      else if (selectedEthnicityTypes.length === 0) textEl.textContent = 'Select types...';
      else if (selectedEthnicityTypes.length <= 2) textEl.textContent = selectedEthnicityTypes.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
      else textEl.textContent = `${selectedEthnicityTypes.length} Types`;
    }
  }

  // Special handler for the consolidated "Race" item
  function selectRaceCharacteristic(element) {
    selectedCharacteristic = '__RACE_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Race';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    const selector = document.getElementById('race-type-selector');
    const optionsContainer = document.getElementById('race-options-container');
    const toggle = document.getElementById('race-type-toggle');
    const dropdown = document.getElementById('race-type-dropdown');
    const allCheckbox = document.getElementById('race-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      raceTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input type="checkbox" class="race-checkbox race-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedRaceTypes = [...raceTypes];
      allCheckbox.checked = true;

      if (!raceDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.race-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedRaceTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        raceDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.race-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedRaceTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedRaceTypes() {
    selectedRaceTypes = Array.from(document.querySelectorAll('.race-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('race-all');
    if (allCheckbox) allCheckbox.checked = selectedRaceTypes.length === raceTypes.length;
    const textEl = document.getElementById('race-type-text');
    if (textEl) {
      if (selectedRaceTypes.length === raceTypes.length) textEl.textContent = 'All Types';
      else if (selectedRaceTypes.length === 0) textEl.textContent = 'Select types...';
      else if (selectedRaceTypes.length <= 2) textEl.textContent = selectedRaceTypes.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
      else textEl.textContent = `${selectedRaceTypes.length} Types`;
    }
  }

  // Special handler for the consolidated "Sex" item
  function selectSexCharacteristic(element) {
    selectedCharacteristic = '__SEX_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Sex';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    const selector = document.getElementById('sex-type-selector');
    const optionsContainer = document.getElementById('sex-options-container');
    const toggle = document.getElementById('sex-type-toggle');
    const dropdown = document.getElementById('sex-type-dropdown');
    const allCheckbox = document.getElementById('sex-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      sexTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input type="checkbox" class="sex-checkbox sex-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedSexTypes = [...sexTypes];
      allCheckbox.checked = true;

      if (!sexDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.sex-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedSexTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        sexDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.sex-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedSexTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedSexTypes() {
    selectedSexTypes = Array.from(document.querySelectorAll('.sex-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('sex-all');
    if (allCheckbox) allCheckbox.checked = selectedSexTypes.length === sexTypes.length;
    const textEl = document.getElementById('sex-type-text');
    if (textEl) {
      if (selectedSexTypes.length === sexTypes.length) textEl.textContent = 'All Types';
      else if (selectedSexTypes.length === 0) textEl.textContent = 'Select types...';
      else if (selectedSexTypes.length <= 2) textEl.textContent = selectedSexTypes.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
      else textEl.textContent = `${selectedSexTypes.length} Types`;
    }
  }

  // Track selected encounter-related types for multi-select
  let selectedAdmissionTypes = [];
  let admissionTypeDropdownInitialized = false;
  let selectedFirstAdmissionLocationTypes = [];
  let firstAdmissionLocationDropdownInitialized = false;
  let selectedEncounterTypes = [];
  let encounterTypeDropdownInitialized = false;

  // Helper function to hide all encounter selectors
  function hideAllEncounterSelectors() {
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');
  }

  // Special handler for the consolidated "Admission type" item
  function selectAdmissionTypeCharacteristic(element) {
    selectedCharacteristic = '__ADMISSION_TYPE_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Admission type';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    const selector = document.getElementById('admission-type-selector');
    const optionsContainer = document.getElementById('admission-type-options-container');
    const toggle = document.getElementById('admission-type-toggle');
    const dropdown = document.getElementById('admission-type-dropdown');
    const allCheckbox = document.getElementById('admission-type-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      admissionTypeTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input type="checkbox" class="admission-type-checkbox admission-type-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedAdmissionTypes = [...admissionTypeTypes];
      allCheckbox.checked = true;

      if (!admissionTypeDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.admission-type-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedAdmissionTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        admissionTypeDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.admission-type-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedAdmissionTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedAdmissionTypes() {
    selectedAdmissionTypes = Array.from(document.querySelectorAll('.admission-type-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('admission-type-all');
    if (allCheckbox) allCheckbox.checked = selectedAdmissionTypes.length === admissionTypeTypes.length;
    const textEl = document.getElementById('admission-type-text');
    if (textEl) {
      if (selectedAdmissionTypes.length === admissionTypeTypes.length) textEl.textContent = 'All Types';
      else if (selectedAdmissionTypes.length === 0) textEl.textContent = 'Select types...';
      else if (selectedAdmissionTypes.length <= 2) textEl.textContent = selectedAdmissionTypes.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
      else textEl.textContent = `${selectedAdmissionTypes.length} Types`;
    }
  }

  // Special handler for the consolidated "First admission location" item
  function selectFirstAdmissionLocationCharacteristic(element) {
    selectedCharacteristic = '__FIRST_ADMISSION_LOCATION_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'First admission location';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    const selector = document.getElementById('first-admission-location-selector');
    const optionsContainer = document.getElementById('first-admission-location-options-container');
    const toggle = document.getElementById('first-admission-location-toggle');
    const dropdown = document.getElementById('first-admission-location-dropdown');
    const allCheckbox = document.getElementById('first-admission-location-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      firstAdmissionLocationTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
        label.innerHTML = `
          <input type="checkbox" class="first-admission-location-checkbox first-admission-location-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${displayName}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedFirstAdmissionLocationTypes = [...firstAdmissionLocationTypes];
      allCheckbox.checked = true;

      if (!firstAdmissionLocationDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.first-admission-location-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedFirstAdmissionLocationTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        firstAdmissionLocationDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.first-admission-location-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedFirstAdmissionLocationTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedFirstAdmissionLocationTypes() {
    selectedFirstAdmissionLocationTypes = Array.from(document.querySelectorAll('.first-admission-location-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('first-admission-location-all');
    if (allCheckbox) allCheckbox.checked = selectedFirstAdmissionLocationTypes.length === firstAdmissionLocationTypes.length;
    const textEl = document.getElementById('first-admission-location-text');
    if (textEl) {
      if (selectedFirstAdmissionLocationTypes.length === firstAdmissionLocationTypes.length) textEl.textContent = 'All Locations';
      else if (selectedFirstAdmissionLocationTypes.length === 0) textEl.textContent = 'Select locations...';
      else if (selectedFirstAdmissionLocationTypes.length <= 2) textEl.textContent = selectedFirstAdmissionLocationTypes.map(t => t.charAt(0).toUpperCase() + t.slice(1)).join(', ');
      else textEl.textContent = `${selectedFirstAdmissionLocationTypes.length} Locations`;
    }
  }

  // Special handler for the consolidated "Encounter type" item
  function selectEncounterTypeCharacteristic(element) {
    selectedCharacteristic = '__ENCOUNTER_TYPE_CONSOLIDATED__';
    selectedCharacteristicDataType = 'percentage';

    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    element.classList.add('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');

    const display = document.getElementById('selected-characteristic-display');
    const nameEl = document.getElementById('selected-characteristic-name');
    if (display && nameEl) {
      nameEl.textContent = 'Encounter type';
      display.classList.remove('hidden');
    }

    // Hide other selectors
    document.getElementById('location-type-selector')?.classList.add('hidden');
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    const selector = document.getElementById('encounter-type-selector');
    const optionsContainer = document.getElementById('encounter-type-options-container');
    const toggle = document.getElementById('encounter-type-toggle');
    const dropdown = document.getElementById('encounter-type-dropdown');
    const allCheckbox = document.getElementById('encounter-type-all');

    if (selector && optionsContainer) {
      optionsContainer.innerHTML = '';
      encounterTypeTypes.forEach(type => {
        const label = document.createElement('label');
        label.className = 'flex items-center px-3 py-2 hover:bg-gray-50 rounded cursor-pointer';
        label.innerHTML = `
          <input type="checkbox" class="encounter-type-checkbox encounter-type-type-checkbox w-4 h-4 text-clif-burgundy border-gray-300 rounded focus:ring-clif-burgundy" value="${type}" checked />
          <span class="ml-2 text-sm text-gray-700">${type}</span>
        `;
        optionsContainer.appendChild(label);
      });

      selectedEncounterTypes = [...encounterTypeTypes];
      allCheckbox.checked = true;

      if (!encounterTypeDropdownInitialized) {
        toggle?.addEventListener('click', (e) => {
          e.stopPropagation();
          dropdown?.classList.toggle('hidden');
        });
        allCheckbox?.addEventListener('change', (e) => {
          document.querySelectorAll('.encounter-type-type-checkbox').forEach(cb => cb.checked = e.target.checked);
          updateSelectedEncounterTypes();
        });
        document.addEventListener('click', (e) => {
          if (!selector.contains(e.target)) dropdown?.classList.add('hidden');
        });
        encounterTypeDropdownInitialized = true;
      }

      optionsContainer.querySelectorAll('.encounter-type-type-checkbox').forEach(cb => {
        cb.addEventListener('change', () => updateSelectedEncounterTypes());
      });
      selector.classList.remove('hidden');
    }

    updateChartTypeDropdown();
    document.getElementById('generate-chart-btn').disabled = false;
  }

  function updateSelectedEncounterTypes() {
    selectedEncounterTypes = Array.from(document.querySelectorAll('.encounter-type-type-checkbox'))
      .filter(cb => cb.checked).map(cb => cb.value);
    const allCheckbox = document.getElementById('encounter-type-all');
    if (allCheckbox) allCheckbox.checked = selectedEncounterTypes.length === encounterTypeTypes.length;
    const textEl = document.getElementById('encounter-type-text');
    if (textEl) {
      if (selectedEncounterTypes.length === encounterTypeTypes.length) textEl.textContent = 'All Types';
      else if (selectedEncounterTypes.length === 0) textEl.textContent = 'Select types...';
      else if (selectedEncounterTypes.length <= 2) textEl.textContent = selectedEncounterTypes.join(', ');
      else textEl.textContent = `${selectedEncounterTypes.length} Types`;
    }
  }

  function filterCategorySidebar(searchTerm) {
    const term = searchTerm.toLowerCase();
    const categories = document.querySelectorAll('.category-section');

    categories.forEach(category => {
      const characteristics = category.querySelectorAll('.characteristic-item');
      let hasVisibleChar = false;

      characteristics.forEach(char => {
        const text = char.textContent.toLowerCase();
        if (text.includes(term)) {
          char.style.display = 'block';
          hasVisibleChar = true;
        } else {
          char.style.display = 'none';
        }
      });

      // Show/hide category based on whether it has visible characteristics
      category.style.display = hasVisibleChar ? 'block' : 'none';

      // If searching, expand categories with matches
      if (term && hasVisibleChar) {
        const charList = category.querySelector('.characteristic-list');
        const chevron = category.querySelector('.chevron');
        charList.style.display = 'block';
        chevron.style.transform = 'rotate(0deg)';
      }
    });
  }

  function generateCustomChart() {
    const chartType = document.getElementById('chart-type-select')?.value;
    let characteristic = selectedCharacteristic;
    const groupBy = document.getElementById('chart-xaxis-select')?.value;

    if (!characteristic) {
      alert('Please select a characteristic from the sidebar to visualize.');
      return;
    }

    // Handle IMV location consolidated selection
    if (characteristic === '__IMV_LOCATION_CONSOLIDATED__') {
      if (selectedLocationTypes.length === 0) {
        alert('Please select at least one location type.');
        return;
      }

      // Always use stacked chart with selected locations
      generateStackedIMVLocationChart(chartType, groupBy, selectedLocationTypes);
      return;
    }

    // Handle ventilator mode consolidated selection
    if (characteristic === '__VENT_MODE_CONSOLIDATED__') {
      if (selectedVentModeTypes.length === 0) {
        alert('Please select at least one ventilator mode type.');
        return;
      }

      // Always use stacked chart with selected modes
      generateStackedVentModeChart(chartType, groupBy, selectedVentModeTypes);
      return;
    }

    // Handle ethnicity consolidated selection
    if (characteristic === '__ETHNICITY_CONSOLIDATED__') {
      if (selectedEthnicityTypes.length === 0) {
        alert('Please select at least one ethnicity type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedEthnicityTypes, ethnicityCharacteristics, 'Ethnicity');
      return;
    }

    // Handle race consolidated selection
    if (characteristic === '__RACE_CONSOLIDATED__') {
      if (selectedRaceTypes.length === 0) {
        alert('Please select at least one race type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedRaceTypes, raceCharacteristics, 'Race');
      return;
    }

    // Handle sex consolidated selection
    if (characteristic === '__SEX_CONSOLIDATED__') {
      if (selectedSexTypes.length === 0) {
        alert('Please select at least one sex type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedSexTypes, sexCharacteristics, 'Sex');
      return;
    }

    // Handle admission type consolidated selection
    if (characteristic === '__ADMISSION_TYPE_CONSOLIDATED__') {
      if (selectedAdmissionTypes.length === 0) {
        alert('Please select at least one admission type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedAdmissionTypes, admissionTypeCharacteristics, 'Admission Type');
      return;
    }

    // Handle first admission location consolidated selection
    if (characteristic === '__FIRST_ADMISSION_LOCATION_CONSOLIDATED__') {
      if (selectedFirstAdmissionLocationTypes.length === 0) {
        alert('Please select at least one location type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedFirstAdmissionLocationTypes, firstAdmissionLocationCharacteristics, 'First Admission Location');
      return;
    }

    // Handle encounter type consolidated selection
    if (characteristic === '__ENCOUNTER_TYPE_CONSOLIDATED__') {
      if (selectedEncounterTypes.length === 0) {
        alert('Please select at least one encounter type.');
        return;
      }
      generateStackedDemographicChart(chartType, groupBy, selectedEncounterTypes, encounterTypeCharacteristics, 'Encounter Type');
      return;
    }

    const filteredData = getFilteredData();

    // Check if ALL sites and ALL years are selected - if so, use Overall columns
    const isAllSites = selectedSites.length === consortiumData.allSites.length;
    const isAllYears = selectedYears.length === consortiumData.allYears.length;
    const useOverallColumns = isAllSites && isAllYears && groupBy === 'site';

    // Collect data based on grouping
    const chartData = {};
    const chartCounts = {}; // Store raw counts for percentage variables (for data labels)
    const iqrData = {}; // Store IQR ranges for median characteristics
    const siteCountsPerGroup = {}; // Track number of sites contributing to each group (for Population variables when grouping by year)
    const yearsPerGroup = {}; // Track years per site (for Population variables when grouping by site)

    // Check if this is a median/IQR characteristic
    const isMedianChar = characteristic.toLowerCase().includes('median') ||
                         characteristic.toLowerCase().includes('[q1') ||
                         (filteredData.length > 0 && valueHasIQR(filteredData[0].characteristics[characteristic] || ''));

    // Check if this is a categorical/percentage characteristic
    // Find the first NON-EMPTY value to determine format (some sites may have empty data)
    let sampleValue = null;
    for (let i = 0; i < filteredData.length; i++) {
      const val = filteredData[i].characteristics[characteristic];
      if (val && val.trim() !== '') {
        sampleValue = val;
        break;
      }
    }
    const isCategoricalPercentage = sampleValue && hasCountPercentageFormat(sampleValue);

    // Check if this is a Population variable (N: Hospitalizations or N: Unique patients)
    const isPopulationVariable = characteristic.trim().startsWith('N: ');

    // Get category for percentage calculation (denominator will be calculated per group)
    let category = null;
    const groupDenominators = {}; // Store denominators per group label
    if (isCategoricalPercentage) {
      category = getCategoryForCharacteristic(characteristic);
    }

    let processedCount = 0;
    let skippedSmallN = 0;
    let skippedNullValue = 0;
    let addedCount = 0;
    const sitesWithData = new Set(); // Track which sites have valid data

    // If using Overall columns (All Sites + All Years + grouped by Site), extract directly from characteristics
    if (useOverallColumns) {
      // Find the characteristic in consortiumData.characteristics
      const charData = consortiumData.characteristics.find(c =>
        c.variable === characteristic || c.variable.trim() === characteristic.trim()
      );

      if (charData) {
        // For each selected site, get the Overall value
        selectedSites.forEach(site => {
          const siteData = charData.sites[site];
          if (!siteData) return;

          const overallValue = siteData['Overall'];
          if (!overallValue || overallValue.trim() === '') {
            skippedNullValue++;
            return;
          }

          processedCount++;

          // Skip if has small n (privacy protection)
          if (hasSmallN(overallValue)) {
            skippedSmallN++;
            return;
          }

          const label = site;

          if (isMedianChar) {
            const medianIQR = extractMedianAndIQR(overallValue);
            if (medianIQR) {
              chartData[label] = medianIQR.median;
              iqrData[label] = {
                q1Values: [medianIQR.q1],
                q3Values: [medianIQR.q3],
                minQ1: medianIQR.q1,
                maxQ3: medianIQR.q3
              };
              sitesWithData.add(site);
              addedCount++;
            }
          } else if (isCategoricalPercentage) {
            const parsed = parseCountPercentage(overallValue);
            if (parsed) {
              chartCounts[label] = parsed.count;

              // Determine denominator based on category and user selection
              let denominatorKey = category === 'Demographics' ? 'N: Unique patients' : 'N: Hospitalizations';

              // Check if user selected IMV as denominator for respiratory support variables
              const respDenomSelector = document.querySelector('input[name="resp-denominator"]:checked');
              const useIMVDenom = respDenomSelector && respDenomSelector.value === 'imv';
              const charLower = characteristic.trim().toLowerCase();
              // Don't use IMV denominator for "Invasive mechanical ventilation" itself (IMV/IMV = 100% always)
              const isIMVCountVariable = charLower.startsWith('invasive mechanical ventilation');
              const isRespSupportVar = charLower.includes('mechanical ventilation') ||
                                       charLower.includes('imv') ||
                                       charLower.includes('fio2') ||
                                       charLower.includes('peep') ||
                                       charLower.includes('ventilator mode') ||
                                       charLower.includes('respiratory rate') ||
                                       charLower.includes('tidal volume') ||
                                       charLower.includes('location at imv');

              if (isRespSupportVar && useIMVDenom && !isIMVCountVariable) {
                denominatorKey = 'Invasive mechanical ventilation, n (%)';
              }

              const denomCharData = consortiumData.characteristics.find(c =>
                c.variable === denominatorKey || c.variable.trim() === denominatorKey
              );

              if (denomCharData && denomCharData.sites[site]) {
                const denomOverallValue = denomCharData.sites[site]['Overall'];
                if (denomOverallValue) {
                  // Handle both formats: "315,193 (30.6%)" and plain numbers
                  const numMatch = denomOverallValue.match(/^\s*([\d,]+)/);
                  if (numMatch) {
                    const denominator = parseInt(numMatch[1].replace(/,/g, ''), 10);
                    groupDenominators[label] = denominator;
                  }
                }
              }

              sitesWithData.add(site);
              addedCount++;
            }
          } else {
            // For regular count values
            const numValue = getNumeric(overallValue);
            if (numValue !== null) {
              chartData[label] = numValue;
              sitesWithData.add(site);

              // Track actual years that have data for this site (for tooltip)
              if (isPopulationVariable) {
                const siteYears = Object.keys(siteData)
                  .filter(key => key !== 'Overall' && !isNaN(parseInt(key)))
                  .filter(year => {
                    const yearValue = siteData[year];
                    return yearValue && yearValue.trim() !== '' && getNumeric(yearValue) !== null;
                  })
                  .sort();
                yearsPerGroup[label] = new Set(siteYears);
              }

              addedCount++;
            }
          }
        });
      }
    } else {
      // Standard data extraction from individual year data
      filteredData.forEach((d, idx) => {
      // Try exact match first, then trimmed match
      let value = d.characteristics[characteristic];

      // If not found, try to find by trimming
      if (!value) {
        const charKey = Object.keys(d.characteristics).find(key =>
          key.trim() === characteristic.trim()
        );
        if (charKey) {
          value = d.characteristics[charKey];
        }
      }

      if (!value) {
        skippedNullValue++;
        return;
      }

      processedCount++;

      // Skip if has small n (privacy protection)
      if (hasSmallN(value)) {
        skippedSmallN++;
        return;
      }

      let label;
      if (groupBy === 'site') {
        label = d.site;
      } else {
        label = d.year;
      }

      if (isMedianChar) {
        // For median/IQR values, use weighted median calculation
        const medianIQR = extractMedianAndIQR(value);

        if (medianIQR) {
          const weight = getWeight(d, characteristic);

          if (weight > 0) {
            // Store weighted median values
            if (!chartData[label]) {
              chartData[label] = [];
            }
            chartData[label].push({ value: medianIQR.median, weight: weight });

            // Track IQR ranges - will aggregate to min Q1 and max Q3
            if (!iqrData[label]) {
              iqrData[label] = { q1Values: [], q3Values: [] };
            }
            iqrData[label].q1Values.push(medianIQR.q1);
            iqrData[label].q3Values.push(medianIQR.q3);

            sitesWithData.add(d.site);
            addedCount++;
          }
        }
      } else if (isCategoricalPercentage) {
        // For categorical percentage variables, sum counts and denominators per group
        const parsed = parseCountPercentage(value);

        if (parsed) {
          // Sum counts per group
          if (!chartCounts[label]) chartCounts[label] = 0;
          chartCounts[label] += parsed.count;

          // Determine denominator based on category and user selection
          let denominatorKey = category === 'Demographics' ? 'N: Unique patients' : 'N: Hospitalizations';

          // Check if user selected IMV as denominator for respiratory support variables
          const respDenomSelector = document.querySelector('input[name="resp-denominator"]:checked');
          const useIMVDenom = respDenomSelector && respDenomSelector.value === 'imv';
          const charLower = characteristic.trim().toLowerCase();
          // Don't use IMV denominator for "Invasive mechanical ventilation" itself (IMV/IMV = 100% always)
          const isIMVCountVariable = charLower.startsWith('invasive mechanical ventilation');
          const isRespSupportVar = charLower.includes('mechanical ventilation') ||
                                   charLower.includes('imv') ||
                                   charLower.includes('fio2') ||
                                   charLower.includes('peep') ||
                                   charLower.includes('ventilator mode') ||
                                   charLower.includes('respiratory rate') ||
                                   charLower.includes('tidal volume') ||
                                   charLower.includes('location at imv');

          if (isRespSupportVar && useIMVDenom && !isIMVCountVariable) {
            denominatorKey = 'Invasive mechanical ventilation, n (%)';
          }

          let denominatorValue = d.characteristics[denominatorKey];

          // Try trimmed match if exact match fails
          if (!denominatorValue) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === denominatorKey
            );
            if (charKey) {
              denominatorValue = d.characteristics[charKey];
            }
          }

          if (denominatorValue) {
            const numMatch = denominatorValue.match(/^\s*([\d,]+)/);
            if (numMatch) {
              const denominator = parseInt(numMatch[1].replace(/,/g, ''), 10);
              if (!groupDenominators[label]) groupDenominators[label] = 0;
              groupDenominators[label] += denominator;
            }
          }

          sitesWithData.add(d.site);
          addedCount++;
        }
      } else {
        // For regular count values, sum them
        const numValue = getNumeric(value);

        if (numValue !== null) {
          if (!chartData[label]) chartData[label] = 0;
          chartData[label] += numValue;
          sitesWithData.add(d.site);

          // Track site/year info per group for Population variables
          if (isPopulationVariable) {
            if (groupBy === 'year') {
              // Track sites when grouping by year
              if (!siteCountsPerGroup[label]) siteCountsPerGroup[label] = new Set();
              siteCountsPerGroup[label].add(d.site);
            } else if (groupBy === 'site') {
              // Track years when grouping by site
              if (!yearsPerGroup[label]) yearsPerGroup[label] = new Set();
              yearsPerGroup[label].add(d.year);
            }
          }

          addedCount++;
        }
      }
    });
    } // End of else block for standard data extraction

    // Calculate weighted medians and aggregate IQR ranges (only for aggregated data, not Overall columns)
    if (isMedianChar && !useOverallColumns) {
      Object.keys(chartData).forEach(key => {
        // Calculate weighted median
        chartData[key] = calculateWeightedMedian(chartData[key]);

        // Aggregate IQR: min of Q1s, max of Q3s
        if (iqrData[key]) {
          iqrData[key].minQ1 = Math.min(...iqrData[key].q1Values);
          iqrData[key].maxQ3 = Math.max(...iqrData[key].q3Values);
        }
      });
    }

    // Calculate percentages for categorical variables using per-group denominators
    if (isCategoricalPercentage) {
      Object.keys(chartCounts).forEach(key => {
        const count = chartCounts[key];
        const denominator = groupDenominators[key];

        if (denominator && denominator > 0) {
          const percentage = (count / denominator) * 100;
          chartData[key] = percentage;
        }
      });
    }

    if (Object.keys(chartData).length === 0) {
      alert(`No data available for "${characteristic}" with the selected filters.\n\nPossible reasons:\n- Not all sites/years have this data point\n- Values may be suppressed for privacy (n < 10)\n- Try selecting different sites or years`);
      return;
    }

    // Destroy existing chart
    if (charts.custom) {
      charts.custom.destroy();
    }

    // Show chart container, hide instructions
    document.getElementById('custom-chart-container')?.classList.remove('hidden');
    document.getElementById('chart-instructions')?.classList.add('hidden');

    // Show 2025 note only if 2025 is in selected years
    const note2025 = document.getElementById('year-2025-note');
    if (note2025) {
      if (selectedYears.includes('2025')) {
        note2025.classList.remove('hidden');
      } else {
        note2025.classList.add('hidden');
      }
    }

    // Show missing sites note if some selected sites don't have data
    const missingSitesNote = document.getElementById('missing-sites-note');
    const missingSitesList = document.getElementById('missing-sites-list');
    if (missingSitesNote && missingSitesList) {
      const missingSites = selectedSites.filter(site => !sitesWithData.has(site));
      if (missingSites.length > 0) {
        missingSitesList.textContent = missingSites.map(s => s.toUpperCase()).join(', ');
        missingSitesNote.classList.remove('hidden');
      } else {
        missingSitesNote.classList.add('hidden');
      }
    }

    // Update title with enhanced format
    const titleEl = document.getElementById('custom-chart-title');
    const subtitleEl = document.getElementById('custom-chart-subtitle');

    if (titleEl) {
      // Build main title - remove redundant ", n (%)" suffix since we'll add the denominator info
      let title = characteristic.replace(/, n \(%\)$/, '').replace(/, n$/, '');

      // Add percentage indicator for categorical variables
      if (isCategoricalPercentage) {
        let denominatorType = category === 'Demographics' ? 'Unique Patients' : 'Hospitalizations';

        // Check if IMV denominator was used for respiratory support
        const respDenomSelector = document.querySelector('input[name="resp-denominator"]:checked');
        const useIMVDenom = respDenomSelector && respDenomSelector.value === 'imv';
        const charLower = characteristic.trim().toLowerCase();
        // Don't use IMV denominator for "Invasive mechanical ventilation" itself (IMV/IMV = 100% always)
        const isIMVCountVariable = charLower.startsWith('invasive mechanical ventilation');
        const isRespSupportVar = charLower.includes('mechanical ventilation') ||
                                 charLower.includes('imv') ||
                                 charLower.includes('fio2') ||
                                 charLower.includes('peep') ||
                                 charLower.includes('ventilator mode') ||
                                 charLower.includes('respiratory rate') ||
                                 charLower.includes('tidal volume') ||
                                 charLower.includes('location at imv');

        if (isRespSupportVar && useIMVDenom && !isIMVCountVariable) {
          denominatorType = 'IMV Hospitalizations';
        }

        title += ` (% of ${denominatorType})`;
      }

      // Add grouping
      const groupingText = groupBy === 'site' ? 'Site' : 'Year';
      title += ` by ${groupingText}`;

      titleEl.textContent = title;
    }

    if (subtitleEl) {
      // Build subtitle with scope information
      let subtitle = '';

      // Sites info
      if (selectedSites.length === 1) {
        subtitle += `Site: ${selectedSites[0]}`;
      } else if (selectedSites.length <= 3) {
        subtitle += `Sites: ${selectedSites.join(', ')}`;
      } else if (selectedSites.length === consortiumData.allSites.length) {
        subtitle += `Sites: All (${selectedSites.length})`;
      } else {
        subtitle += `Sites: ${selectedSites.length} selected`;
      }

      // Years info
      subtitle += ' | ';

      if (selectedYears.length === 1) {
        subtitle += `Year: ${selectedYears[0]}`;
      } else if (selectedYears.length <= 4) {
        subtitle += `Years: ${selectedYears.join(', ')}`;
      } else if (selectedYears.length === consortiumData.allYears.length) {
        subtitle += `Years: All (${selectedYears[0]}-${selectedYears[selectedYears.length-1]})`;
      } else {
        subtitle += `Years: ${selectedYears[0]}-${selectedYears[selectedYears.length-1]} (${selectedYears.length} selected)`;
      }

      // Add aggregation note for percentage variables
      if (isCategoricalPercentage) {
        if (groupBy === 'year' && selectedSites.length > 1) {
          subtitle += '  Sites combined per year';
        } else if (groupBy === 'site' && selectedYears.length > 1) {
          subtitle += '  Years combined per site';
        }
      }

      subtitleEl.textContent = subtitle;
    }

    // Generate colors
    let labels = Object.keys(chartData);

    // Sort labels: alphabetically for sites, numerically for years
    if (groupBy === 'site') {
      labels.sort((a, b) => a.localeCompare(b));
    } else {
      labels.sort((a, b) => parseInt(a) - parseInt(b));
    }

    const colors = generateChartColors(labels.length, labels, groupBy);

    // Map data values to match the sorted label order
    const sortedData = labels.map(label => chartData[label]);

    // Handle Error Bar chart type specially
    if (chartType === 'medianiqr' && isMedianChar) {
      const ctx = document.getElementById('custom-chart');
      if (ctx) {
        // Check if this is a SOFA component score (not Total SOFA)
        const isSOFAComponent = characteristic.includes('Respiratory, median') ||
                                characteristic.includes('Coagulation, median') ||
                                characteristic.includes('Liver, median') ||
                                characteristic.includes('Cardiovascular, median') ||
                                characteristic.includes('CNS, median') ||
                                characteristic.includes('Renal, median');

        // Create data for scatter plot with error bars drawn via plugin
        const medianPoints = labels.map((label, index) => ({
          x: index,
          y: chartData[label]
        }));

        // Store IQR data for the error bar plugin
        const errorBarData = labels.map(label => {
          const iqr = iqrData[label];
          if (iqr && iqr.minQ1 !== undefined && iqr.maxQ3 !== undefined) {
            return { q1: iqr.minQ1, q3: iqr.maxQ3 };
          }
          return { q1: 0, q3: 0 };
        });

        // Calculate max Y value to ensure all Q3 values are visible
        const maxQ3 = Math.max(...errorBarData.map(d => d.q3).filter(v => v > 0));
        const maxMedian = Math.max(...medianPoints.map(p => p.y).filter(v => v > 0));
        const dataMax = Math.max(maxQ3, maxMedian);
        // Round up to a nice number for the Y-axis max
        let yAxisMax;
        if (isSOFAComponent) {
          yAxisMax = 4;
        } else {
          // Add padding and round to a nice number
          const paddedMax = dataMax * 1.1;
          if (paddedMax <= 10) {
            yAxisMax = Math.ceil(paddedMax); // Round to nearest integer for small values
          } else if (paddedMax <= 50) {
            yAxisMax = Math.ceil(paddedMax / 5) * 5; // Round to nearest 5
          } else if (paddedMax <= 100) {
            yAxisMax = Math.ceil(paddedMax / 10) * 10; // Round to nearest 10
          } else {
            yAxisMax = Math.ceil(paddedMax / 50) * 50; // Round to nearest 50 for large values
          }
        }

        // Get site-specific colors for error bars when grouped by site
        const errorBarColors = groupBy === 'site'
          ? labels.map(label => getSiteColor(label, 1)) // Full opacity for error bars
          : labels.map(() => 'rgba(128, 0, 32, 1)');

        // Custom plugin to draw error bars (vertical lines)
        const errorBarPlugin = {
          id: 'errorBars',
          afterDatasetsDraw: function(chart) {
            const ctx = chart.ctx;
            const xAxis = chart.scales.x;
            const yAxis = chart.scales.y;
            const dataset = chart.data.datasets[0];

            ctx.save();
            ctx.lineWidth = 2;

            dataset.data.forEach((point, index) => {
              const errorData = errorBarData[index];
              if (!errorData) return;

              // Use site-specific color for this error bar
              ctx.strokeStyle = errorBarColors[index];

              const x = xAxis.getPixelForValue(index);
              const yQ1 = yAxis.getPixelForValue(errorData.q1);
              const yQ3 = yAxis.getPixelForValue(errorData.q3);

              // Draw vertical line from Q1 to Q3
              ctx.beginPath();
              ctx.moveTo(x, yQ1);
              ctx.lineTo(x, yQ3);
              ctx.stroke();

              // Draw horizontal caps at Q1 and Q3
              const capWidth = 8;
              ctx.beginPath();
              ctx.moveTo(x - capWidth, yQ1);
              ctx.lineTo(x + capWidth, yQ1);
              ctx.stroke();

              ctx.beginPath();
              ctx.moveTo(x - capWidth, yQ3);
              ctx.lineTo(x + capWidth, yQ3);
              ctx.stroke();
            });

            ctx.restore();
          }
        };

        // Get point colors - site-specific when grouped by site
        const pointColors = groupBy === 'site'
          ? labels.map(label => getSiteColor(label, 1))
          : labels.map(() => 'rgba(128, 0, 32, 1)');

        const config = {
          type: 'scatter',
          data: {
            labels: labels,
            datasets: [
              {
                label: 'Median [IQR]',
                data: medianPoints,
                backgroundColor: pointColors,
                borderColor: pointColors,
                pointRadius: 8,
                pointStyle: 'circle'
              }
            ]
          },
          plugins: [errorBarPlugin],
          options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
              legend: {
                display: false
              },
              datalabels: {
                display: false
              },
              tooltip: {
                callbacks: {
                  label: function(context) {
                    const index = context.dataIndex;
                    const labelName = labels[index];
                    const median = context.parsed.y;
                    const iqr = iqrData[labelName];
                    if (iqr) {
                      return `${labelName}: ${median.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })} [${iqr.minQ1.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}, ${iqr.maxQ3.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}]`;
                    }
                    return `${labelName}: ${median.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}`;
                  }
                }
              }
            },
            scales: {
              x: {
                type: 'category',
                labels: labels,
                grid: {
                  display: true
                }
              },
              y: {
                beginAtZero: true,
                max: yAxisMax, // SOFA components are 0-4, others scale to fit Q3 values
                title: {
                  display: true,
                  text: characteristic.replace(/, median \[Q1, Q3\]/, '').replace(/ median \[Q1, Q3\]/, '')
                }
              }
            }
          }
        };

        charts.custom = new Chart(ctx, config);
        return; // Exit early - chart is created
      }
    }

    // Create chart
    const ctx = document.getElementById('custom-chart');
    if (ctx) {
      const config = {
        type: chartType,
        data: {
          labels: labels,
          datasets: [{
            label: characteristic,
            data: sortedData,
            backgroundColor: colors.background,
            borderColor: colors.border,
            borderWidth: 2
          }]
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          plugins: {
            legend: {
              display: chartType === 'pie',
              position: 'bottom'
            },
            datalabels: chartType === 'bar' ? {
              color: '#000',
              anchor: function(context) {
                // For 0 values, anchor at start so label appears above baseline
                return context.dataset.data[context.dataIndex] === 0 ? 'start' : 'end';
              },
              align: 'top',
              offset: function(context) {
                // Add more offset for 0 values so they're visible
                return context.dataset.data[context.dataIndex] === 0 ? 4 : 4;
              },
              font: {
                weight: 'bold',
                size: 11
              },
              display: function(context) {
                // Only display labels for 0 values (both median and categorical)
                const value = context.dataset.data[context.dataIndex];
                if (isMedianChar || isCategoricalPercentage) {
                  return value === 0;
                }
                return false;
              },
              formatter: function(value, context) {
                const labelName = context.chart.data.labels[context.dataIndex];
                // Only format for 0 values (display function already filters)
                if (isCategoricalPercentage) {
                  // Show "0%" for zero percentage values
                  return '0%';
                } else if (isMedianChar) {
                  // Show the median value with IQR for 0 values
                  const medianStr = value.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
                  const iqr = iqrData[labelName];
                  if (iqr && iqr.minQ1 !== undefined && iqr.maxQ3 !== undefined) {
                    const q1Str = iqr.minQ1.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
                    const q3Str = iqr.maxQ3.toLocaleString(undefined, { minimumFractionDigits: 0, maximumFractionDigits: 1 });
                    return `${medianStr} [${q1Str},${q3Str}]`;
                  }
                  return medianStr;
                }
                return '';
              }
            } : {
              display: false
            },
            tooltip: {
              callbacks: {
                label: function(context) {
                  const labelName = context.label || '';
                  const value = context.parsed.y !== undefined ? context.parsed.y : context.parsed;

                  if (isMedianChar && iqrData[labelName]) {
                    // For median characteristics, show weighted median and IQR range
                    const minQ1 = iqrData[labelName].minQ1;
                    const maxQ3 = iqrData[labelName].maxQ3;
                    return [
                      `${labelName}: ${value.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}`,
                      `IQR: [${minQ1.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}, ${maxQ3.toLocaleString(undefined, { minimumFractionDigits: 1, maximumFractionDigits: 1 })}]`
                    ];
                  } else if (isCategoricalPercentage) {
                    // For categorical percentage variables, show both percentage and count
                    const count = chartCounts[labelName];
                    return [
                      `${labelName}: ${value.toFixed(1)}%`,
                      `n = ${count ? count.toLocaleString() : 'N/A'}`
                    ];
                  } else {
                    // For count characteristics, just show the value
                    let label = labelName;
                    if (label) {
                      label += ': ';
                    }
                    label += value.toLocaleString();

                    // For Population variables, show contextual info based on grouping
                    if (isPopulationVariable) {
                      if (groupBy === 'year' && siteCountsPerGroup[labelName]) {
                        // Show site count when grouped by year
                        const siteCount = siteCountsPerGroup[labelName].size;
                        return [label, `(${siteCount} site${siteCount !== 1 ? 's' : ''})`];
                      } else if (groupBy === 'site' && yearsPerGroup[labelName]) {
                        // Show year range when grouped by site
                        const years = Array.from(yearsPerGroup[labelName]).sort();
                        const yearRange = years.length === 1 ? years[0] : `${years[0]}-${years[years.length - 1]}`;
                        return [label, `(${yearRange})`];
                      }
                    }
                    return label;
                  }
                }
              }
            }
          },
          scales: chartType === 'pie' ? {} : {
            x: {
              beginAtZero: true
            },
            y: {
              beginAtZero: true,
              title: isCategoricalPercentage ? {
                display: true,
                text: 'Percentage (%)'
              } : undefined
            }
          }
        }
      };

      charts.custom = new Chart(ctx, config);
    }
  }

  // Generate stacked bar chart for selected IMV location types
  function generateStackedIMVLocationChart(chartType, groupBy, locationTypesToShow) {
    const filteredData = getFilteredData();

    // Check if ALL sites and ALL years are selected - if so, use Overall columns
    const isAllSites = selectedSites.length === consortiumData.allSites.length;
    const isAllYears = selectedYears.length === consortiumData.allYears.length;
    const useOverallColumns = isAllSites && isAllYears && groupBy === 'site';

    // Use provided location types or default to all
    const locationsToProcess = locationTypesToShow || imvLocationTypes;

    // Check if this is a grouped bar or line chart (% of IMV comparison)
    // Only stacked bar uses distribution; grouped bar and line use % of IMV
    const useIMVPercentage = chartType === 'grouped' || chartType === 'line';

    // For grouped bar and line charts, always use IMV hospitalizations as denominator
    const useIMVDenom = true;

    // First pass: collect ALL counts for selected location types
    // Structure: { locationType: { label: count } }
    const allLocationCounts = {};
    const allLabels = new Set();
    const sitesWithData = new Set();

    // For grouped bar charts, also collect denominator counts
    const denominatorCounts = {};

    // Collect counts for each location type
    locationsToProcess.forEach(locationType => {
      const characteristic = imvLocationCharacteristics[locationType];
      allLocationCounts[locationType] = {};

      if (useOverallColumns) {
        const charData = consortiumData.characteristics.find(c =>
          c.variable === characteristic || c.variable.trim() === characteristic.trim()
        );

        if (charData) {
          selectedSites.forEach(site => {
            const siteData = charData.sites[site];
            if (!siteData) return;

            const overallValue = siteData['Overall'];
            if (!overallValue || overallValue.trim() === '' || hasSmallN(overallValue)) return;

            const parsed = parseCountPercentage(overallValue);
            if (parsed) {
              allLabels.add(site);
              allLocationCounts[locationType][site] = parsed.count;
              sitesWithData.add(site);
            }
          });
        }
      } else {
        filteredData.forEach(d => {
          let value = d.characteristics[characteristic];
          if (!value) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === characteristic.trim()
            );
            if (charKey) value = d.characteristics[charKey];
          }

          if (!value || hasSmallN(value)) return;

          const parsed = parseCountPercentage(value);
          if (parsed) {
            const label = groupBy === 'site' ? d.site : d.year;
            allLabels.add(label);

            if (!allLocationCounts[locationType][label]) allLocationCounts[locationType][label] = 0;
            allLocationCounts[locationType][label] += parsed.count;
            sitesWithData.add(d.site);
          }
        });
      }
    });

    // For grouped bar and line charts, collect denominator counts (% of IMV)
    if (useIMVPercentage) {
      const denominatorKey = 'Invasive mechanical ventilation, n (%)';

      if (useOverallColumns) {
        const denomCharData = consortiumData.characteristics.find(c =>
          c.variable === denominatorKey || c.variable.trim() === denominatorKey
        );

        if (denomCharData) {
          selectedSites.forEach(site => {
            const siteData = denomCharData.sites[site];
            if (!siteData) return;

            const overallValue = siteData['Overall'];
            if (overallValue) {
              const numMatch = overallValue.match(/^\s*([\d,]+)/);
              if (numMatch) {
                denominatorCounts[site] = parseInt(numMatch[1].replace(/,/g, ''), 10);
              }
            }
          });
        }
      } else {
        // Aggregate denominator counts per label
        filteredData.forEach(d => {
          let value = d.characteristics[denominatorKey];
          if (!value) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === denominatorKey.trim()
            );
            if (charKey) value = d.characteristics[charKey];
          }

          if (value) {
            const numMatch = value.match(/^\s*([\d,]+)/);
            if (numMatch) {
              const count = parseInt(numMatch[1].replace(/,/g, ''), 10);
              const label = groupBy === 'site' ? d.site : d.year;
              if (!denominatorCounts[label]) denominatorCounts[label] = 0;
              denominatorCounts[label] += count;
            }
          }
        });
      }
    }

    // Calculate total counts per label (sum of selected location types) - for stacked distribution
    const totalCountsPerLabel = {};
    Array.from(allLabels).forEach(label => {
      totalCountsPerLabel[label] = 0;
      locationsToProcess.forEach(locationType => {
        totalCountsPerLabel[label] += allLocationCounts[locationType][label] || 0;
      });
    });

    // Build datasets with percentages calculated from n values
    const datasets = [];
    const colors = generateChartColors(locationsToProcess.length);

    locationsToProcess.forEach((locationType, colorIndex) => {
      const locationData = {};
      const locationCounts = allLocationCounts[locationType];

      // Calculate percentages based on chart type
      Object.keys(locationCounts).forEach(label => {
        const count = locationCounts[label];

        if (useIMVPercentage) {
          // For grouped bar and line: use IMV hospitalizations as denominator
          const denominator = denominatorCounts[label];
          if (denominator && denominator > 0) {
            locationData[label] = (count / denominator) * 100;
          }
        } else {
          // For stacked: use total counts of selected location types as denominator
          const totalForLabel = totalCountsPerLabel[label];
          if (totalForLabel && totalForLabel > 0) {
            locationData[label] = (count / totalForLabel) * 100;
          }
        }
      });

      datasets.push({
        label: locationType.charAt(0).toUpperCase() + locationType.slice(1),
        data: locationData,
        counts: locationCounts,
        backgroundColor: colors.background[colorIndex],
        borderColor: colors.border[colorIndex],
        borderWidth: 1
      });
    });

    if (allLabels.size === 0) {
      alert('No data available for the selected filters.');
      return;
    }

    // Destroy existing chart
    if (charts.custom) {
      charts.custom.destroy();
    }

    // Show chart container, hide instructions
    document.getElementById('custom-chart-container')?.classList.remove('hidden');
    document.getElementById('chart-instructions')?.classList.add('hidden');

    // Show 2025 note if applicable
    const note2025 = document.getElementById('year-2025-note');
    if (note2025) {
      note2025.classList.toggle('hidden', !selectedYears.includes('2025'));
    }

    // Show missing sites note
    const missingSitesNote = document.getElementById('missing-sites-note');
    const missingSitesList = document.getElementById('missing-sites-list');
    if (missingSitesNote && missingSitesList) {
      const missingSites = selectedSites.filter(site => !sitesWithData.has(site));
      if (missingSites.length > 0) {
        missingSitesList.textContent = missingSites.map(s => s.toUpperCase()).join(', ');
        missingSitesNote.classList.remove('hidden');
      } else {
        missingSitesNote.classList.add('hidden');
      }
    }

    // Update title
    const titleEl = document.getElementById('custom-chart-title');
    const subtitleEl = document.getElementById('custom-chart-subtitle');

    if (titleEl) {
      const groupingText = groupBy === 'site' ? 'Site' : 'Year';
      let titleText = 'First Location at IMV Start';
      if (locationsToProcess.length < imvLocationTypes.length) {
        // Show which locations are selected
        if (locationsToProcess.length === 1) {
          titleText = `First Location at IMV Start: ${locationsToProcess[0].charAt(0).toUpperCase() + locationsToProcess[0].slice(1)}`;
        } else {
          titleText = `First Location at IMV Start (${locationsToProcess.length} types)`;
        }
      }

      if (useIMVPercentage) {
        titleEl.textContent = `${titleText} (% of IMV Hospitalizations) by ${groupingText}`;
      } else {
        titleEl.textContent = `${titleText} - Distribution by ${groupingText}`;
      }
    }

    if (subtitleEl) {
      let subtitle = '';
      if (selectedSites.length === consortiumData.allSites.length) {
        subtitle += `Sites: All (${selectedSites.length})`;
      } else if (selectedSites.length <= 3) {
        subtitle += `Sites: ${selectedSites.join(', ')}`;
      } else {
        subtitle += `Sites: ${selectedSites.length} selected`;
      }
      subtitle += ' | ';
      if (selectedYears.length === consortiumData.allYears.length) {
        subtitle += `Years: All (${selectedYears[0]}-${selectedYears[selectedYears.length-1]})`;
      } else if (selectedYears.length <= 4) {
        subtitle += `Years: ${selectedYears.join(', ')}`;
      } else {
        subtitle += `Years: ${selectedYears[0]}-${selectedYears[selectedYears.length-1]} (${selectedYears.length} selected)`;
      }
      subtitleEl.textContent = subtitle;
    }

    // Sort labels
    let labels = Array.from(allLabels);
    if (groupBy === 'site') {
      labels.sort((a, b) => a.localeCompare(b));
    } else {
      labels.sort((a, b) => parseInt(a) - parseInt(b));
    }

    // Build chart datasets with total counts for tooltip
    const totalCountsArray = labels.map(label => totalCountsPerLabel[label] || 0);

    // Determine if we're creating a line chart or bar chart
    const isLineChart = chartType === 'line';

    const chartDatasets = datasets.map(ds => {
      const baseDataset = {
        label: ds.label,
        data: labels.map(label => ds.data[label] || 0),
        backgroundColor: ds.backgroundColor,
        borderColor: ds.borderColor,
        borderWidth: isLineChart ? 2 : 1,
        counts: labels.map(label => ds.counts[label] || 0)
      };

      // Add line chart specific properties
      if (isLineChart) {
        baseDataset.fill = false;
        baseDataset.tension = 0.1;
        baseDataset.pointRadius = 4;
        baseDataset.pointHoverRadius = 6;
      }

      return baseDataset;
    });

    // Create chart (bar or line based on selection)
    const ctx = document.getElementById('custom-chart');
    if (ctx) {
      const config = {
        type: isLineChart ? 'line' : 'bar',
        data: {
          labels: labels,
          datasets: chartDatasets,
          totalCounts: totalCountsArray // Store for tooltip access
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              position: 'bottom'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: function(tooltipItems) {
                  return tooltipItems[0]?.label || '';
                },
                label: function(context) {
                  const value = context.parsed.y;
                  const count = context.dataset.counts[context.dataIndex];
                  // Only show if there's data (value > 0)
                  if (value > 0) {
                    return `${context.dataset.label}: ${value.toFixed(1)}% (n=${count.toLocaleString()})`;
                  }
                  return null; // Skip zero values
                },
                footer: function(tooltipItems) {
                  // Show total n for this group
                  const dataIndex = tooltipItems[0]?.dataIndex;
                  const totalN = tooltipItems[0]?.chart.data.totalCounts[dataIndex] || 0;
                  return `Total: n=${totalN.toLocaleString()}`;
                }
              }
            },
            datalabels: {
              display: false
            }
          },
          scales: {
            x: {
              stacked: !useIMVPercentage // Stack only for stacked bar charts
            },
            y: {
              stacked: !useIMVPercentage, // Stack only for stacked bar charts
              beginAtZero: true,
              max: useIMVPercentage ? undefined : 100, // Remove max for % of IMV charts
              title: {
                display: true,
                text: 'Percentage (%)'
              }
            }
          }
        }
      };

      charts.custom = new Chart(ctx, config);
    }
  }

  // Generate chart for selected ventilator mode types
  function generateStackedVentModeChart(chartType, groupBy, modeTypesToShow) {
    const filteredData = getFilteredData();

    // Check if ALL sites and ALL years are selected - if so, use Overall columns
    const isAllSites = selectedSites.length === consortiumData.allSites.length;
    const isAllYears = selectedYears.length === consortiumData.allYears.length;
    const useOverallColumns = isAllSites && isAllYears && groupBy === 'site';

    // Use provided mode types or default to all
    const modesToProcess = modeTypesToShow || ventModeTypes;

    // Check if this is a grouped bar or line chart (% of IMV comparison)
    // Only stacked bar uses distribution; grouped bar and line use % of IMV
    const useIMVPercentage = chartType === 'grouped' || chartType === 'line';

    // For grouped bar and line charts, always use IMV hospitalizations as denominator
    const useIMVDenom = true;

    // First pass: collect ALL counts for selected mode types
    // Structure: { modeType: { label: count } }
    const allModeCounts = {};
    const allLabels = new Set();
    const sitesWithData = new Set();

    // For grouped bar and line charts, collect denominator counts
    const denominatorCounts = {};

    // Collect counts for each mode type
    modesToProcess.forEach(modeType => {
      const characteristic = ventModeCharacteristics[modeType];
      allModeCounts[modeType] = {};

      if (useOverallColumns) {
        const charData = consortiumData.characteristics.find(c =>
          c.variable === characteristic || c.variable.trim() === characteristic.trim()
        );

        if (charData) {
          selectedSites.forEach(site => {
            const siteData = charData.sites[site];
            if (!siteData) return;

            const overallValue = siteData['Overall'];
            if (!overallValue || overallValue.trim() === '' || hasSmallN(overallValue)) return;

            const parsed = parseCountPercentage(overallValue);
            if (parsed) {
              allLabels.add(site);
              allModeCounts[modeType][site] = parsed.count;
              sitesWithData.add(site);
            }
          });
        }
      } else {
        filteredData.forEach(d => {
          let value = d.characteristics[characteristic];
          if (!value) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === characteristic.trim()
            );
            if (charKey) value = d.characteristics[charKey];
          }

          if (!value || hasSmallN(value)) return;

          const parsed = parseCountPercentage(value);
          if (parsed) {
            const label = groupBy === 'site' ? d.site : d.year;
            allLabels.add(label);

            if (!allModeCounts[modeType][label]) allModeCounts[modeType][label] = 0;
            allModeCounts[modeType][label] += parsed.count;
            sitesWithData.add(d.site);
          }
        });
      }
    });

    // For grouped bar and line charts, collect denominator counts (% of IMV)
    if (useIMVPercentage) {
      const denominatorKey = 'Invasive mechanical ventilation, n (%)';

      if (useOverallColumns) {
        const denomCharData = consortiumData.characteristics.find(c =>
          c.variable === denominatorKey || c.variable.trim() === denominatorKey
        );

        if (denomCharData) {
          selectedSites.forEach(site => {
            const siteData = denomCharData.sites[site];
            if (!siteData) return;

            const overallValue = siteData['Overall'];
            if (overallValue) {
              const numMatch = overallValue.match(/^\s*([\d,]+)/);
              if (numMatch) {
                denominatorCounts[site] = parseInt(numMatch[1].replace(/,/g, ''), 10);
              }
            }
          });
        }
      } else {
        // Aggregate denominator counts per label
        filteredData.forEach(d => {
          let value = d.characteristics[denominatorKey];
          if (!value) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === denominatorKey.trim()
            );
            if (charKey) value = d.characteristics[charKey];
          }

          if (value) {
            const numMatch = value.match(/^\s*([\d,]+)/);
            if (numMatch) {
              const count = parseInt(numMatch[1].replace(/,/g, ''), 10);
              const label = groupBy === 'site' ? d.site : d.year;
              if (!denominatorCounts[label]) denominatorCounts[label] = 0;
              denominatorCounts[label] += count;
            }
          }
        });
      }
    }

    // Calculate total counts per label (sum of selected mode types) - for stacked distribution
    const totalCountsPerLabel = {};
    Array.from(allLabels).forEach(label => {
      totalCountsPerLabel[label] = 0;
      modesToProcess.forEach(modeType => {
        totalCountsPerLabel[label] += allModeCounts[modeType][label] || 0;
      });
    });

    // Build datasets with percentages calculated from n values
    const datasets = [];
    const colors = generateChartColors(modesToProcess.length);

    modesToProcess.forEach((modeType, colorIndex) => {
      const modeData = {};
      const modeCounts = allModeCounts[modeType];

      // Calculate percentages based on chart type
      Object.keys(modeCounts).forEach(label => {
        const count = modeCounts[label];

        if (useIMVPercentage) {
          // For grouped bar and line: use IMV hospitalizations as denominator
          const denominator = denominatorCounts[label];
          if (denominator && denominator > 0) {
            modeData[label] = (count / denominator) * 100;
          }
        } else {
          // For stacked: use total counts of selected mode types as denominator
          const totalForLabel = totalCountsPerLabel[label];
          if (totalForLabel && totalForLabel > 0) {
            modeData[label] = (count / totalForLabel) * 100;
          }
        }
      });

      // Capitalize first letter of each word for display
      const displayName = modeType.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');

      datasets.push({
        label: displayName,
        data: modeData,
        counts: modeCounts,
        backgroundColor: colors.background[colorIndex],
        borderColor: colors.border[colorIndex],
        borderWidth: 1
      });
    });

    if (allLabels.size === 0) {
      alert('No data available for the selected filters.');
      return;
    }

    // Destroy existing chart
    if (charts.custom) {
      charts.custom.destroy();
    }

    // Show chart container, hide instructions
    document.getElementById('custom-chart-container')?.classList.remove('hidden');
    document.getElementById('chart-instructions')?.classList.add('hidden');

    // Show 2025 note if applicable
    const note2025 = document.getElementById('year-2025-note');
    if (note2025) {
      note2025.classList.toggle('hidden', !selectedYears.includes('2025'));
    }

    // Show missing sites note
    const missingSitesNote = document.getElementById('missing-sites-note');
    const missingSitesList = document.getElementById('missing-sites-list');
    if (missingSitesNote && missingSitesList) {
      const missingSites = selectedSites.filter(site => !sitesWithData.has(site));
      if (missingSites.length > 0) {
        missingSitesList.textContent = missingSites.map(s => s.toUpperCase()).join(', ');
        missingSitesNote.classList.remove('hidden');
      } else {
        missingSitesNote.classList.add('hidden');
      }
    }

    // Update title
    const titleEl = document.getElementById('custom-chart-title');
    const subtitleEl = document.getElementById('custom-chart-subtitle');

    if (titleEl) {
      const groupingText = groupBy === 'site' ? 'Site' : 'Year';
      let titleText = 'Initial Ventilator Mode';
      if (modesToProcess.length < ventModeTypes.length) {
        // Show which modes are selected
        if (modesToProcess.length === 1) {
          const displayName = modesToProcess[0].split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
          titleText = `Initial Ventilator Mode: ${displayName}`;
        } else {
          titleText = `Initial Ventilator Mode (${modesToProcess.length} types)`;
        }
      }

      if (useIMVPercentage) {
        titleEl.textContent = `${titleText} (% of IMV Hospitalizations) by ${groupingText}`;
      } else {
        titleEl.textContent = `${titleText} - Distribution by ${groupingText}`;
      }
    }

    if (subtitleEl) {
      let subtitle = '';
      if (selectedSites.length === consortiumData.allSites.length) {
        subtitle += `Sites: All (${selectedSites.length})`;
      } else if (selectedSites.length <= 3) {
        subtitle += `Sites: ${selectedSites.join(', ')}`;
      } else {
        subtitle += `Sites: ${selectedSites.length} selected`;
      }
      subtitle += ' | ';
      if (selectedYears.length === consortiumData.allYears.length) {
        subtitle += `Years: All (${selectedYears[0]}-${selectedYears[selectedYears.length-1]})`;
      } else if (selectedYears.length <= 4) {
        subtitle += `Years: ${selectedYears.join(', ')}`;
      } else {
        subtitle += `Years: ${selectedYears[0]}-${selectedYears[selectedYears.length-1]} (${selectedYears.length} selected)`;
      }
      subtitleEl.textContent = subtitle;
    }

    // Sort labels
    let labels = Array.from(allLabels);
    if (groupBy === 'site') {
      labels.sort((a, b) => a.localeCompare(b));
    } else {
      labels.sort((a, b) => parseInt(a) - parseInt(b));
    }

    // Build chart datasets with total counts for tooltip
    const totalCountsArray = labels.map(label => totalCountsPerLabel[label] || 0);

    // Determine if we're creating a line chart or bar chart
    const isLineChart = chartType === 'line';

    const chartDatasets = datasets.map(ds => {
      const baseDataset = {
        label: ds.label,
        data: labels.map(label => ds.data[label] || 0),
        backgroundColor: ds.backgroundColor,
        borderColor: ds.borderColor,
        borderWidth: isLineChart ? 2 : 1,
        counts: labels.map(label => ds.counts[label] || 0)
      };

      // Add line chart specific properties
      if (isLineChart) {
        baseDataset.fill = false;
        baseDataset.tension = 0.1;
        baseDataset.pointRadius = 4;
        baseDataset.pointHoverRadius = 6;
      }

      return baseDataset;
    });

    // Create chart (bar or line based on selection)
    const ctx = document.getElementById('custom-chart');
    if (ctx) {
      const config = {
        type: isLineChart ? 'line' : 'bar',
        data: {
          labels: labels,
          datasets: chartDatasets,
          totalCounts: totalCountsArray // Store for tooltip access
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              position: 'bottom'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: function(tooltipItems) {
                  return tooltipItems[0]?.label || '';
                },
                label: function(context) {
                  const value = context.parsed.y;
                  const count = context.dataset.counts[context.dataIndex];
                  // Only show if there's data (value > 0)
                  if (value > 0) {
                    return `${context.dataset.label}: ${value.toFixed(1)}% (n=${count.toLocaleString()})`;
                  }
                  return null; // Skip zero values
                },
                footer: function(tooltipItems) {
                  // Show total n for this group
                  const dataIndex = tooltipItems[0]?.dataIndex;
                  const totalN = tooltipItems[0]?.chart.data.totalCounts[dataIndex] || 0;
                  return `Total: n=${totalN.toLocaleString()}`;
                }
              }
            },
            datalabels: {
              display: false
            }
          },
          scales: {
            x: {
              stacked: !useIMVPercentage // Stack only for stacked bar charts
            },
            y: {
              stacked: !useIMVPercentage, // Stack only for stacked bar charts
              beginAtZero: true,
              max: useIMVPercentage ? undefined : 100, // Remove max for % of IMV charts
              title: {
                display: true,
                text: 'Percentage (%)'
              }
            }
          }
        }
      };

      charts.custom = new Chart(ctx, config);
    }
  }

  // Generic function to generate stacked demographic charts (Ethnicity, Race, Sex)
  function generateStackedDemographicChart(chartType, groupBy, typesToShow, characteristicsMap, demographicName) {
    const filteredData = getFilteredData();

    const isAllSites = selectedSites.length === consortiumData.allSites.length;
    const isAllYears = selectedYears.length === consortiumData.allYears.length;
    const useOverallColumns = isAllSites && isAllYears && groupBy === 'site';

    // Get ALL types from characteristicsMap (not just selected ones) for proper denominator calculation
    const allTypes = Object.keys(characteristicsMap);

    // Collect counts for ALL types (needed for proper percentage calculation)
    const allTypeCounts = {};
    const allLabels = new Set();
    const sitesWithData = new Set();

    // First, collect data for ALL types to calculate proper totals
    allTypes.forEach(type => {
      const characteristic = characteristicsMap[type];
      allTypeCounts[type] = {};

      if (useOverallColumns) {
        const charData = consortiumData.characteristics.find(c =>
          c.variable === characteristic || c.variable.trim() === characteristic.trim()
        );

        if (charData) {
          selectedSites.forEach(site => {
            const siteData = charData.sites[site];
            if (!siteData) return;

            const overallValue = siteData['Overall'];
            if (!overallValue || overallValue.trim() === '' || hasSmallN(overallValue)) return;

            const parsed = parseCountPercentage(overallValue);
            if (parsed) {
              allLabels.add(site);
              allTypeCounts[type][site] = parsed.count;
              // Only track sitesWithData for types we're showing
              if (typesToShow.includes(type)) {
                sitesWithData.add(site);
              }
            }
          });
        }
      } else {
        filteredData.forEach(d => {
          let value = d.characteristics[characteristic];
          if (!value) {
            const charKey = Object.keys(d.characteristics).find(key =>
              key.trim() === characteristic.trim()
            );
            if (charKey) value = d.characteristics[charKey];
          }

          if (!value || hasSmallN(value)) return;

          const parsed = parseCountPercentage(value);
          if (parsed) {
            const label = groupBy === 'site' ? d.site : d.year;
            allLabels.add(label);

            if (!allTypeCounts[type][label]) allTypeCounts[type][label] = 0;
            allTypeCounts[type][label] += parsed.count;
            // Only track sitesWithData for types we're showing
            if (typesToShow.includes(type)) {
              sitesWithData.add(d.site);
            }
          }
        });
      }
    });

    // Calculate totals per label using ALL types (proper denominator)
    const totalCountsPerLabel = {};
    Array.from(allLabels).forEach(label => {
      totalCountsPerLabel[label] = 0;
      allTypes.forEach(type => {
        totalCountsPerLabel[label] += allTypeCounts[type][label] || 0;
      });
    });

    // Build datasets
    const datasets = [];

    // Get sorted labels first (needed for single-type site coloring)
    let sortedLabels = Array.from(allLabels);
    if (groupBy === 'site') {
      sortedLabels.sort((a, b) => a.localeCompare(b));
    } else {
      sortedLabels.sort((a, b) => parseInt(a) - parseInt(b));
    }

    // When only one type is selected and grouping by site, use site-specific colors
    const useSiteColors = typesToShow.length === 1 && groupBy === 'site';
    const colors = useSiteColors
      ? generateChartColors(sortedLabels.length, sortedLabels, 'site')
      : generateChartColors(typesToShow.length);

    typesToShow.forEach((type, colorIndex) => {
      const typeData = {};
      const typeCounts = allTypeCounts[type];

      Object.keys(typeCounts).forEach(label => {
        const count = typeCounts[label];
        const totalForLabel = totalCountsPerLabel[label];
        if (totalForLabel && totalForLabel > 0) {
          typeData[label] = (count / totalForLabel) * 100;
        }
      });

      const displayName = type.split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');

      // For single type with site grouping, use per-bar colors
      if (useSiteColors) {
        datasets.push({
          label: displayName,
          data: typeData,
          counts: typeCounts,
          backgroundColor: colors.background, // Array of colors per bar
          borderColor: colors.border,
          borderWidth: 1
        });
      } else {
        datasets.push({
          label: displayName,
          data: typeData,
          counts: typeCounts,
          backgroundColor: colors.background[colorIndex],
          borderColor: colors.border[colorIndex],
          borderWidth: 1
        });
      }
    });

    if (allLabels.size === 0) {
      alert('No data available for the selected filters.');
      return;
    }

    if (charts.custom) {
      charts.custom.destroy();
    }

    document.getElementById('custom-chart-container')?.classList.remove('hidden');
    document.getElementById('chart-instructions')?.classList.add('hidden');

    const note2025 = document.getElementById('year-2025-note');
    if (note2025) {
      note2025.classList.toggle('hidden', !selectedYears.includes('2025'));
    }

    const missingSitesNote = document.getElementById('missing-sites-note');
    const missingSitesList = document.getElementById('missing-sites-list');
    if (missingSitesNote && missingSitesList) {
      const missingSites = selectedSites.filter(site => !sitesWithData.has(site));
      if (missingSites.length > 0) {
        missingSitesList.textContent = missingSites.map(s => s.toUpperCase()).join(', ');
        missingSitesNote.classList.remove('hidden');
      } else {
        missingSitesNote.classList.add('hidden');
      }
    }

    const titleEl = document.getElementById('custom-chart-title');
    const subtitleEl = document.getElementById('custom-chart-subtitle');

    if (titleEl) {
      const groupingText = groupBy === 'site' ? 'Site' : 'Year';
      const allTypes = Object.keys(characteristicsMap);
      let titleText = demographicName;
      if (typesToShow.length < allTypes.length) {
        if (typesToShow.length === 1) {
          const displayName = typesToShow[0].split(' ').map(word => word.charAt(0).toUpperCase() + word.slice(1)).join(' ');
          titleText = `${demographicName}: ${displayName}`;
        } else {
          titleText = `${demographicName} (${typesToShow.length} types)`;
        }
      }
      titleEl.textContent = `${titleText} - Distribution by ${groupingText}`;
    }

    if (subtitleEl) {
      let subtitle = '';
      if (selectedSites.length === consortiumData.allSites.length) {
        subtitle += `Sites: All (${selectedSites.length})`;
      } else if (selectedSites.length <= 3) {
        subtitle += `Sites: ${selectedSites.join(', ')}`;
      } else {
        subtitle += `Sites: ${selectedSites.length} selected`;
      }
      subtitle += ' | ';
      if (selectedYears.length === consortiumData.allYears.length) {
        subtitle += `Years: All (${selectedYears[0]}-${selectedYears[selectedYears.length-1]})`;
      } else if (selectedYears.length <= 4) {
        subtitle += `Years: ${selectedYears.join(', ')}`;
      } else {
        subtitle += `Years: ${selectedYears[0]}-${selectedYears[selectedYears.length-1]} (${selectedYears.length} selected)`;
      }
      subtitleEl.textContent = subtitle;
    }

    // Use already sorted labels
    const labels = sortedLabels;

    const totalCountsArray = labels.map(label => totalCountsPerLabel[label] || 0);
    const isLineChart = chartType === 'line';
    const isGroupedBar = chartType === 'grouped';
    const isStacked = chartType === 'stacked';

    const chartDatasets = datasets.map(ds => {
      const baseDataset = {
        label: ds.label,
        data: labels.map(label => ds.data[label] || 0),
        backgroundColor: ds.backgroundColor,
        borderColor: ds.borderColor,
        borderWidth: isLineChart ? 2 : 1,
        counts: labels.map(label => ds.counts[label] || 0)
      };

      if (isLineChart) {
        baseDataset.fill = false;
        baseDataset.tension = 0.1;
        baseDataset.pointRadius = 4;
        baseDataset.pointHoverRadius = 6;
      }

      return baseDataset;
    });

    const ctx = document.getElementById('custom-chart');
    if (ctx) {
      const config = {
        type: isLineChart ? 'line' : 'bar',
        data: {
          labels: labels,
          datasets: chartDatasets,
          totalCounts: totalCountsArray
        },
        options: {
          responsive: true,
          maintainAspectRatio: false,
          interaction: {
            mode: 'index',
            intersect: false
          },
          plugins: {
            legend: {
              display: true,
              position: 'bottom'
            },
            tooltip: {
              mode: 'index',
              intersect: false,
              callbacks: {
                title: function(tooltipItems) {
                  return tooltipItems[0]?.label || '';
                },
                label: function(context) {
                  const value = context.parsed.y;
                  const count = context.dataset.counts[context.dataIndex];
                  if (value > 0) {
                    return `${context.dataset.label}: ${value.toFixed(1)}% (n=${count.toLocaleString()})`;
                  }
                  return null;
                },
                footer: function(tooltipItems) {
                  const dataIndex = tooltipItems[0]?.dataIndex;
                  const totalN = tooltipItems[0]?.chart.data.totalCounts[dataIndex] || 0;
                  return `Total: n=${totalN.toLocaleString()}`;
                }
              }
            },
            datalabels: {
              display: false
            }
          },
          scales: {
            x: {
              stacked: isStacked
            },
            y: {
              stacked: isStacked,
              beginAtZero: true,
              max: isStacked ? 100 : undefined,
              title: {
                display: true,
                text: 'Percentage (%)'
              }
            }
          }
        }
      };

      charts.custom = new Chart(ctx, config);
    }
  }

  function clearCustomChart() {
    if (charts.custom) {
      charts.custom.destroy();
      charts.custom = null;
    }
    document.getElementById('custom-chart-container')?.classList.add('hidden');
    document.getElementById('chart-instructions')?.classList.remove('hidden');

    // Hide all notes
    document.getElementById('year-2025-note')?.classList.add('hidden');
    document.getElementById('missing-sites-note')?.classList.add('hidden');

    // Clear selected characteristic
    selectedCharacteristic = null;
    selectedCharacteristicDataType = null;
    document.querySelectorAll('.characteristic-item').forEach(item => {
      item.classList.remove('bg-clif-burgundy', 'bg-opacity-20', 'text-clif-burgundy', 'font-semibold');
    });
    document.getElementById('selected-characteristic-display')?.classList.add('hidden');

    // Hide respiratory support denominator selector
    document.getElementById('resp-denominator-selector')?.classList.add('hidden');

    // Hide location type selector
    document.getElementById('location-type-selector')?.classList.add('hidden');

    // Hide ventilator mode type selector
    document.getElementById('vent-mode-type-selector')?.classList.add('hidden');

    // Hide demographic type selectors
    document.getElementById('ethnicity-type-selector')?.classList.add('hidden');
    document.getElementById('race-type-selector')?.classList.add('hidden');
    document.getElementById('sex-type-selector')?.classList.add('hidden');

    // Hide encounter type selectors
    document.getElementById('admission-type-selector')?.classList.add('hidden');
    document.getElementById('first-admission-location-selector')?.classList.add('hidden');
    document.getElementById('encounter-type-selector')?.classList.add('hidden');

    // Reset chart type dropdown to default options
    updateChartTypeDropdown();

    // Disable generate button
    const generateBtn = document.getElementById('generate-chart-btn');
    if (generateBtn) {
      generateBtn.disabled = true;
    }
  }

  // Site-specific colors for consistent visualization across all charts
  // These colors are unique to sites and NOT used by any other chart elements
  const SITE_COLORS = {
    'emory':    'rgba(165, 42, 42, 0.7)',     // brown
    'jhu':      'rgba(0, 114, 178, 0.7)',     // blue
    'nu':       'rgba(0, 158, 115, 0.7)',     // teal-green
    'ohsu':     'rgba(230, 159, 0, 0.7)',     // golden yellow
    'rush':     'rgba(128, 0, 128, 0.7)',     // purple
    'ucmc':     'rgba(86, 180, 233, 0.7)',    // sky blue
    'ucsf':     'rgba(240, 128, 128, 0.7)',   // light coral/pink
    'umich':    'rgba(105, 105, 105, 0.7)',   // dim gray
    'umn':      'rgba(0, 128, 0, 0.7)',       // green
    'upenn':    'rgba(255, 127, 14, 0.7)',    // orange
    'utoronto': 'rgba(139, 0, 0, 0.7)',       // dark red
  };

  function getSiteColor(siteName, opacity = 0.7) {
    const normalizedSite = siteName.toLowerCase().trim();
    const color = SITE_COLORS[normalizedSite];
    if (color) {
      return opacity === 0.7 ? color : color.replace('0.7', String(opacity));
    }
    // Fallback for unknown sites
    return `rgba(100, 100, 100, ${opacity})`;
  }

  function generateChartColors(count, labels = null, groupBy = null) {
    const fallbackColors = [
      'rgba(139, 0, 0, 0.7)',      // burgundy
      'rgba(59, 130, 246, 0.7)',   // blue
      'rgba(16, 185, 129, 0.7)',   // green
      'rgba(245, 158, 11, 0.7)',   // amber
      'rgba(168, 85, 247, 0.7)',   // purple
      'rgba(236, 72, 153, 0.7)',   // pink
      'rgba(239, 68, 68, 0.7)',    // red
      'rgba(14, 165, 233, 0.7)',   // sky
      'rgba(34, 197, 94, 0.7)',    // emerald
      'rgba(251, 146, 60, 0.7)',   // orange
    ];

    const background = [];
    const border = [];

    // If grouping by site and labels are provided, use site-specific colors
    if (groupBy === 'site' && labels && labels.length > 0) {
      for (let i = 0; i < labels.length; i++) {
        const siteColor = getSiteColor(labels[i]);
        background.push(siteColor);
        border.push(siteColor.replace('0.7', '1'));
      }
    } else {
      // Use fallback colors for non-site groupings
      for (let i = 0; i < count; i++) {
        const color = fallbackColors[i % fallbackColors.length];
        background.push(color);
        border.push(color.replace('0.7', '1'));
      }
    }

    return { background, border };
  }

  function updateCharts() {
    // This is called when filters change - reinitialize the chart builder
    initializeChartBuilder();
  }

  function updateTable() {
    const searchTerm = document.getElementById('table-search')?.value.toLowerCase() || '';
    const tbody = document.getElementById('table-body');
    const thead = document.querySelector('#data-table thead tr');

    if (!tbody || !thead) return;

    // Use overall data for table view (ignores site/year filters)
    const { headers, data } = overallTableData;

    // Build table headers - Characteristic + all site columns
    thead.innerHTML = `
      <th class="px-4 py-3 text-left font-semibold sticky left-0 bg-clif-burgundy z-10">Characteristic</th>
      ${headers.map(header => `<th class="px-3 py-3 text-left font-semibold text-xs min-w-[100px] max-w-[150px]" style="word-wrap: break-word; white-space: normal;">${header}</th>`).join('')}
    `;

    // Populate table body
    tbody.innerHTML = '';

    data.forEach(row => {
      const characteristic = row.characteristic;

      // Apply search filter
      const matchesSearch = characteristic.toLowerCase().includes(searchTerm) ||
        Object.values(row.values).some(v => v.toLowerCase().includes(searchTerm));

      if (matchesSearch) {
        const tr = document.createElement('tr');
        tr.className = 'hover:bg-gray-50';

        let html = `<td class="px-4 py-3 text-sm text-gray-700 font-medium sticky left-0 bg-white">${characteristic}</td>`;
        headers.forEach(header => {
          const value = row.values[header] || '-';
          html += `<td class="px-4 py-3 text-sm text-gray-700">${value}</td>`;
        });

        tr.innerHTML = html;
        tbody.appendChild(tr);
      }
    });
  }

  function exportToCSV() {
    // Use overall data for CSV export
    const { headers, data } = overallTableData;

    // Build CSV header
    let csv = 'Characteristic,' + headers.join(',') + '\n';

    // Build CSV rows
    data.forEach(row => {
      const characteristic = `"${row.characteristic}"`;
      const values = headers.map(header => `"${row.values[header] || '-'}"`).join(',');
      csv += `${characteristic},${values}\n`;
    });

    const blob = new Blob([csv], { type: 'text/csv' });
    const url = window.URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `clif-overall-data-${new Date().toISOString().split('T')[0]}.csv`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    window.URL.revokeObjectURL(url);
  }
</script>

<style>
  .interactive-dashboard {
    animation: fadeIn 0.5s ease-in;
  }

  @keyframes fadeIn {
    from {
      opacity: 0;
      transform: translateY(20px);
    }
    to {
      opacity: 1;
      transform: translateY(0);
    }
  }

  #data-table {
    font-size: 0.875rem;
  }

  #data-table thead {
    position: sticky;
    top: 0;
    z-index: 1;
  }

  /* Category Sidebar Styles */
  .category-header:hover {
    background-color: rgb(249, 250, 251);
  }

  .characteristic-list {
    display: none;
    background-color: rgb(249, 250, 251);
  }

  .characteristic-item {
    border-left: 3px solid transparent;
  }

  .characteristic-item:hover {
    border-left-color: rgb(136, 19, 55);
  }

  .characteristic-item.bg-clif-burgundy {
    border-left-color: rgb(136, 19, 55);
  }

  .chevron {
    transition: transform 0.2s ease;
  }

  /* Scrollbar styling for sidebar */
  #categories-list::-webkit-scrollbar {
    width: 8px;
  }

  #categories-list::-webkit-scrollbar-track {
    background: rgb(243, 244, 246);
  }

  #categories-list::-webkit-scrollbar-thumb {
    background: rgb(209, 213, 219);
    border-radius: 4px;
  }

  #categories-list::-webkit-scrollbar-thumb:hover {
    background: rgb(156, 163, 175);
  }
</style>
